<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="mask-icon" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bigshuimu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="水木君的个人博客">
<meta property="og:url" content="https://bigshuimu.github.io/index.html">
<meta property="og:site_name" content="水木君的个人博客">
<meta property="og:locale">
<meta property="article:author" content="水木君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bigshuimu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>水木君的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">水木君的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://bigshuimu.github.io/2024/03/23/%E5%A4%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
      <meta itemprop="name" content="水木君">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水木君的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/23/%E5%A4%8D%E8%AF%95/" class="post-title-link" itemprop="url">复试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-23 15:57:02" itemprop="dateCreated datePublished" datetime="2024-03-23T15:57:02+08:00">2024-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-29 14:08:49" itemprop="dateModified" datetime="2024-03-29T14:08:49+08:00">2024-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="前后端交互的方式"><a href="#前后端交互的方式" class="headerlink" title="前后端交互的方式"></a>前后端交互的方式</h3><p>Fetch API 是一种现代、强大的网络请求API，它提供了一个JavaScript接口，用于访问和操作HTTP管道的部分，例如请求和响应。它提供了一个全局 <code>fetch()</code> 方法，该方法提供了一种简单、合理的方式来异步获取资源网络上的资源。Fetch API 允许你通过第二个参数自定义请求的许多方面，包括HTTP方法、头部、body等：</p>
<h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别?"></a>get和post的区别?</h3><ol>
<li><strong>数据传输方式</strong>：<ul>
<li><strong>GET</strong>：将请求数据附加在 URL 之后，以查询字符串的形式出现。由于浏览器和服务器对 URL 长度有限制，因此能发送的数据量较小。</li>
<li><strong>POST</strong>：将请求数据放在 HTTP 请求的 body 中，不会暴露在 URL 上。理论上可以发送更多的数据。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li><strong>GET</strong>：由于数据在 URL 中可见，因此不适合发送敏感信息。</li>
<li><strong>POST</strong>：数据不会显示在 URL 中，相对更安全，适合发送敏感信息。</li>
</ul>
</li>
<li><strong>幂等性</strong>：<ul>
<li><strong>GET</strong>：是幂等的，意味着多次执行同一请求，资源的状态不会改变。</li>
<li><strong>POST</strong>：不是幂等的，每次请求都可能修改服务器上的资源状态。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li><strong>GET</strong>：用于请求数据，如查询、搜索等。</li>
<li><strong>POST</strong>：用于提交数据到服务器，如表单提交。</li>
</ul>
</li>
<li><strong>缓存</strong>：<ul>
<li><strong>GET</strong>：请求可以被缓存。(浏览器可以直接从缓存中加载这些资源，而不是再次从服务器请求它们)</li>
<li><strong>POST</strong>：请求默认不被缓存。</li>
</ul>
</li>
</ol>
<h3 id="极客商城是一个什么样的项目"><a href="#极客商城是一个什么样的项目" class="headerlink" title="极客商城是一个什么样的项目"></a>极客商城是一个什么样的项目</h3><p>极客商城是一个专门针对手机端用户设计的web商城项目，。通过精心的设计和开发，极客商城实现了商品的展示、购买、管理等核心功能，同时也提供了购物车、用户评论、商品搜索等辅助功能，以增强用户的购物体验和便利性。</p>
<p>在技术实现方面，极客商城采用了当下流行的前端技术栈，包括HTML、CSS和JavaScript，确保了页面的响应速度和交互体验。特别是使用了Vue 2框架，它以数据驱动和组件化的开发思想，帮助开发者高效地构建动态的用户界面。此外，项目还采用了uni-app框架，这是一个使用Vue.js开发所有前端应用的框架，它允许开发者编写一次代码，就可以发布到iOS、Android、Web等多个平台，极大地提高了开发效率和项目的可维护性。</p>
<p>在后端技术上，极客商城基于Node.js进行开发，Node.js是一个基于Chrome V8引擎的JavaScript运行环境，它使得JavaScript可以脱离浏览器环境，直接在服务器端运行。这种技术选择不仅使得前后端开发语言统一，而且Node.js的非阻塞I/O和事件驱动的特性，也让极客商城的服务器能够处理大量并发请求，保证了商城系统的高性能和稳定性。</p>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>XPath，全称为XML Path Language，是一种在XML文档中查找信息的语言。它被设计用来遍历和处理XML文档的结构，允许开发者编写查询，从而定位到文档中特定的元素、属性或者文本内容。由于XML的结构和HTML非常相似，XPath也经常被用于对HTML文档进行查询，尤其在Web爬虫和一些需要解析HTML文档的应用中十分常见。</p>
<ul>
<li><strong>节点选择</strong>：<code>/</code>表示从根节点开始选择，<code>//</code>可以从任何位置开始搜索匹配的节点。</li>
<li><strong>属性选择</strong>：<code>@</code>用于选择属性。例如，<code>//book[@lang=&#39;en&#39;]</code>选择所有<code>lang</code>属性为<code>en</code>的<code>book</code>元素。</li>
<li><strong>谓词</strong>：方括号<code>[]</code>用于提供谓词，精确地过滤节点。例如，<code>//book[price&gt;35.00]</code>选择所有<code>price</code>元素值大于35.00的<code>book</code>元素。</li>
<li><strong>通配符</strong>：<code>*</code>表示匹配任何元素节点，例如，<code>//*</code>选择文档中的所有元素。</li>
<li><strong>轴</strong>：定义了节点和其他节点之间的树关系，如<code>ancestor</code>、<code>child</code>、<code>descendant</code>等。例如，<code>//title/ancestor::book</code>选择所有<code>title</code>元素的<code>book</code>祖先元素。</li>
</ul>
<h3 id="vue2的特点，相对于传统js有何区别？"><a href="#vue2的特点，相对于传统js有何区别？" class="headerlink" title="vue2的特点，相对于传统js有何区别？"></a>vue2的特点，相对于传统js有何区别？</h3><ol>
<li><p><strong>响应式数据绑定</strong>：</p>
<ul>
<li>Vue 2使用双向数据绑定，意味着将JavaScript对象与UI绑定起来，当数据发生变化时，界面会自动更新。这使得状态管理变得简单直观。</li>
</ul>
</li>
<li><p><strong>组件化</strong>：</p>
<ul>
<li>应用被划分为可重用的组件，每个组件包含自己的模板、逻辑和样式。这种模块化的方式提高了代码的复用性和测试性。</li>
</ul>
</li>
<li><p><strong>虚拟DOM</strong>：</p>
<ul>
<li>Vue 2使用虚拟DOM来优化渲染过程。通过比较新旧虚拟DOM的差异，Vue可以仅更新必要的DOM元素，而不是重绘整个页面，从而提高性能。</li>
</ul>
</li>
</ol>
<h3 id="解释TSBased-AEXPath算法"><a href="#解释TSBased-AEXPath算法" class="headerlink" title="解释TSBased-AEXPath算法"></a>解释TSBased-AEXPath算法</h3><ol>
<li><strong>加载网页内容</strong>：使用Selenium加载动态网页，获取页面源代码。</li>
<li><strong>解析HTML为树结构</strong>：使用<code>lxml</code>解析页面源代码，构建树形结构。</li>
</ol>
<p>通常情况下同一站点内的不同详情页面基本 框架结构一致，除去广告内容和链接等相同内容， 剩下不同部分通常是有效内容部分。可以等价的说， 同一站点(或同一站点内的某一个模块)的不同页面 的网页内容在提取过程中通常有效 Xpath 都分布在 这些 Xpath 路径相同但对应内容不同的 Xpath 中。</p>
<h3 id="介绍一下redis，对比mysql的区别"><a href="#介绍一下redis，对比mysql的区别" class="headerlink" title="介绍一下redis，对比mysql的区别"></a>介绍一下redis，对比mysql的区别</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是一种二叉搜索树，其中任何节点的两个子树的高度差不超过1。这种平衡条件确保树保持较低的高度，从而在进行插入、删除和查找操作时保持较高的性能，即操作的时间复杂度保持在O(log n)，其中n是树中节点的数量。</p>
<h3 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h3><p>m 阶的B+树与m阶的B树的主要差异如下：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在<br>B 树中，具有n个关键字的结点含有n+1棵子树。<br>2）在B+树中，每个结点（非根内部结点）的关键字个数n的范围是m/2≤n≤m（根结点：<br>2≤n≤m）；在B树中，每个结点（非根内部结点）的关键字个数n的范围是m/2-1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；<br>而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。</p>
<h3 id="怎么理解数据结构"><a href="#怎么理解数据结构" class="headerlink" title="怎么理解数据结构"></a>怎么理解数据结构</h3><p>数据结构是计算机存储、组织数据的方式，它不仅包括数据元素的集合，还包括数据元素之间的关系及操作。通过合理的数据结构可以高效地存取和处理数据。常见的数据结构有数组、栈、队列、链表、树、图等，每种结构有其特定的用途和优势，选择合适的数据结构是解决问题和优化程序性能的关键。</p>
<h3 id="迭代和递归的特点，并比较优缺点"><a href="#迭代和递归的特点，并比较优缺点" class="headerlink" title="迭代和递归的特点，并比较优缺点"></a>迭代和递归的特点，并比较优缺点</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>程序调用自身的编程技巧称为递归</p>
<p>1）大问题化为小问题,可以极大的减少代码量；</p>
<p>2）用有限的语句来定义对象的无限集合.；</p>
<p>3）代码更简洁清晰，可读性更好</p>
<p>1）递归调用函数,浪费空间；</p>
<p>2）递归太深容易造成堆栈的溢出；</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B.</p>
<p>1）迭代效率高，运行时间只因循环次数增加而增加；</p>
<p>2）没什么额外开销，空间上也没有什么增加，</p>
<p>1） 不容易理解；</p>
<p>2） 代码不如递归简洁；</p>
<p>3） 编写复杂问题时困难。</p>
<p>二者关系</p>
<p>1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。</p>
<p>2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>查找</th>
<th>平均时间复杂度</th>
<th>查找条件</th>
<th>算法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找</td>
<td>O<sub>(n)<sub/></td>
<td>无序或有序队列</td>
<td>按顺序比较每个元素，直到找到关键字为止</td>
</tr>
<tr>
<td>二分查找（折半查找）</td>
<td>O<sub>(logn)<sub/></td>
<td>有序数组</td>
<td>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</td>
</tr>
<tr>
<td>二叉排序树查找</td>
<td>O<sub>(logn)<sub/></td>
<td>二叉排序树</td>
<td>在二叉查找树b中查找x的过程为：1．若b是空树，则搜索失败二叉排序树查找2．若x等于b的根节点的数据域之值，则查找成功；3．若x小于b的根节点的数据域之值，则搜索左子树4．查找右子树。</td>
</tr>
<tr>
<td>哈希表法（散列表）</td>
<td>O<sub>(1)<sub/></td>
<td>先创建哈希表（散列表）</td>
<td>根据键值方式（Key value）进行查找，通过散列函数，定位数据元素</td>
</tr>
<tr>
<td>分块查找</td>
<td>O<sub>(logn)<sub/></td>
<td>无序或有序队列</td>
<td>将n个数据元素＂按块有序”划分为m块（m≤n）。每一块中的结点不必有序，但块与块之间必须“按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…….然后使用二分查找及顺序查找。</td>
</tr>
</tbody>
</table>
</div>
<p>哈希表（散列表）：<br>适用场景：数据量大，需快速查找、插入和删除。<br>缺点：在最坏情况下（所有元素都映射到同一个槽）时间复杂度退化为 O(n)；不适合范围查找。</p>
<p>二叉搜索树（尤其是平衡二叉搜索树如AVL树、红黑树）：<br>适用场景：需要快速查找、插入和删除，同时保持数据有序。<br>优点：查找、插入和删除操作的时间复杂度平均为<br>缺点：维护成本高，需要额外的旋转操作来保持平衡。</p>
<p>B树和B+树（数据库和文件系统中常用）：<br>适用场景：大量数据存储在外部存储器（如硬盘）上时。<br>优点：减少磁盘I/O次数，提高存取效率。<br>缺点：实现复杂。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>排序法</th>
<th>最差时间复杂度</th>
<th>平均时间复杂度</th>
<th>稳定度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉树</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不一定</td>
<td>O(n)</td>
</tr>
<tr>
<td>快速</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定</td>
<td>O(log<sub>2</sub>n) ~O(n)</td>
</tr>
<tr>
<td>堆</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>希尔</td>
<td>-</td>
<td>-</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h3><p>（升序）以某个记录的关键字为划分元，将整个数据分为两组，左边的数据小于等于划分元，右边的数据大于等于划分元。对左右两组数据，再各自选择一个划分元，将两组数据划分为更小的序列，这样一直进行下去，直到整个序列有序。</p>
<h3 id="应用层协议："><a href="#应用层协议：" class="headerlink" title="应用层协议："></a>应用层协议：</h3><p>1、远程登录协议(Telnet)<br>2、文件传输协议（FTP）<br>3、超文本传输协议（HTTP）<br>4、域名服务协议（DNS）<br>5、简单邮件传输协议（SMTP）<br>6、邮局协议（POP3）</p>
<p>其中，从网络上下载文件时使用的是FTP协议，上网游览网页时使用的是HTTP协议；在网络上访问一台主机时，通常不直接输入IP地址，而是输入域名，用的是DNS服务协议，它会将域名解析为IP地址；通过FoxMail发送电子邮件时，使用SMTP协议，接收电子邮件时就使用POP3协议。</p>
<h3 id="传输层协议："><a href="#传输层协议：" class="headerlink" title="传输层协议："></a>传输层协议：</h3><p>1、传输控制协议TCP<br>2、用户数据报协议UDP</p>
<p>TCP协议：面向连接的可靠传输协议。利用TCP进行通信时，首先要通过三步握手，以建立通信双方的连接。TCP提供了数据的确认和数据重传的机制，保证发送的数据一定能到达通信的对方。</p>
<p>UDP协议：是无连接的，不可靠的传输协议。采用UDP进行通信时不用建立连接，可以直接向一个IP地址发送数据，但是不能保证对方是否能收到。</p>
<h3 id="网络层协议："><a href="#网络层协议：" class="headerlink" title="网络层协议："></a>网络层协议：</h3><p>网际协议 (IP)：这是用于发送数据包从一个主机传送到另一个主机的协议，主要用于路由选择。它仅负责传送，不保证数据包的顺序和完整性。</p>
<p>互联网控制报文协议 (ICMP)：该协议用于IP主机、路由器之间传递控制消息，例如目的不可达、时间超出等，用于错误报告和状态查询。</p>
<p>互联网组织管理协议 (IGMP)：用于在IP主机和相邻的路由器之间管理多播组成员资格的协议。</p>
<p>地址解析协议 (ARP)：用于在本地网络内部解析网络层的地址到链路层地址，例如将IP地址转换为以太网的MAC地址。</p>
<h3 id="程序和软件有何不同"><a href="#程序和软件有何不同" class="headerlink" title="程序和软件有何不同"></a>程序和软件有何不同</h3><p>程序和软件的区别是，软件是为了完成特定的功能，解决特定的问题而用计算机语言编写的命令序列集合，可以理解为应用程序的集合。而应用程序是软件的一个组成部分，它是软件的必要元素。</p>
<h3 id="数组与链表有什么区别？"><a href="#数组与链表有什么区别？" class="headerlink" title="数组与链表有什么区别？"></a>数组与链表有什么区别？</h3><p>数组在内存中占用连续空间，支持快速随机访问，但大小固定，扩容复杂。链表由独立节点组成，每个节点指向下一个，支持灵活插入和删除操作，但访问特定元素较慢。数组适合频繁访问，链表适合频繁修改。</p>
<h3 id="度为2的树与二叉树有什么区别"><a href="#度为2的树与二叉树有什么区别" class="headerlink" title="度为2的树与二叉树有什么区别"></a>度为2的树与二叉树有什么区别</h3><p>度为2的树指的是每个节点最多有两个子节点的树，但子节点的顺序和数量不固定，可以只有一个子节点或没有。而二叉树是一种特殊的度为2的树，每个节点最多有两个子节点，且子节点有明确的左右之分。简而言之，所有二叉树都是度为2的树，但不是所有度为2的树都是二叉树。</p>
<h3 id="最小生成树有哪几种方法"><a href="#最小生成树有哪几种方法" class="headerlink" title="最小生成树有哪几种方法"></a>最小生成树有哪几种方法</h3><p>构建最小生成树的主要算法有两种：普里姆算法（Prim’s Algorithm）和克鲁斯卡尔算法（Kruskal’s Algorithm）。普里姆算法从任意顶点开始，逐步增加边，直到包含所有顶点，侧重于节点的扩展。克鲁斯卡尔算法从最小的边开始构建，逐步添加边到生成树中，直到连接所有顶点，侧重于边的选择。这两种方法都能有效找到图的最小生成树，选择哪一种取决于具体问题的特点</p>
<h3 id="时间复杂度为nlogn的排序算法有哪些？"><a href="#时间复杂度为nlogn的排序算法有哪些？" class="headerlink" title="时间复杂度为nlogn的排序算法有哪些？"></a>时间复杂度为nlogn的排序算法有哪些？</h3><p>快速排序、归并排序、堆排序</p>
<h3 id="图的存储方式有哪些？每一种方式优缺点"><a href="#图的存储方式有哪些？每一种方式优缺点" class="headerlink" title="图的存储方式有哪些？每一种方式优缺点"></a>图的存储方式有哪些？每一种方式优缺点</h3><p>图的主要存储方式有邻接矩阵和邻接表：</p>
<ul>
<li><strong>邻接矩阵</strong>：使用二维数组表示节点间的连接关系，优点是直观、访问速度快，适合表示稠密图；缺点是占用空间大，不适合稀疏图。</li>
<li><strong>邻接表</strong>：为每个节点维护一个列表，列出所有直接相连的节点，优点是空间效率高，适合稀疏图；缺点是访问特定边的速度不如邻接矩阵快。</li>
</ul>
<h3 id="图的遍历和树的遍历有哪些区别"><a href="#图的遍历和树的遍历有哪些区别" class="headerlink" title="图的遍历和树的遍历有哪些区别"></a>图的遍历和树的遍历有哪些区别</h3><p>图的遍历包括深度优先搜索（DFS）和广度优先搜索（BFS），需要特别注意避免重复访问节点，通常通过标记已访问的节点来实现。树的遍历（如前序、中序、后序和层序遍历）不需担心重复访问，因为树结构保证了每个节点只被访问一次。图的遍历更加复杂，因为图可能包含环，需要记录访问过的节点以防止无限循环；而树是一种没有环的特殊图，其遍历更直接、简单。</p>
<h3 id="二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？"><a href="#二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？" class="headerlink" title="二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？"></a>二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？</h3><p>二叉排序树（BST），又称二叉搜索树，通过将每个新插入的节点放置在正确的位置来维持元素的有序性：每个节点的左子树只包含小于节点的元素，右子树只包含大于节点的元素。这使得查找、插入和删除操作的平均时间复杂度为 O(logn)<br>O(logn)，其中 n 是树中节点的数量。</p>
<p>最好情况：树是完全平衡的，所有操作的时间复杂度为 O(logn)<br>最坏情况：树高度等于节点数（即树退化为链表），所有操作的时间复杂度退化为 O(n)</p>
<h3 id="说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况"><a href="#说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况" class="headerlink" title="说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况"></a>说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况</h3><p>最小生成树算法主要有普里姆算法（Prim’s）和克鲁斯卡尔算法（Kruskal’s）：<br>普里姆算法：<br>时间复杂度：依赖于数据结构，使用优先队列时为 O(ElogV)。<br>过程：从任一顶点开始，逐渐增加边，总是选择连接已有树与未连接顶点中最小的边。<br>适用情况：适用于稠密图，因为它依赖于顶点数。</p>
<p>克鲁斯卡尔算法：<br>时间复杂度：O(ElogE) 或 O(ElogV)，主要由排序边的时间复杂度决定。<br>过程：按边的权重顺序处理所有边，选择不形成环的边，直至连接所有顶点。<br>适用情况：适用于稀疏图，因为算法从边的角度出发。</p>
<h3 id="关键路径和关键活动的概念"><a href="#关键路径和关键活动的概念" class="headerlink" title="关键路径和关键活动的概念"></a>关键路径和关键活动的概念</h3><p>在数据结构中，关键路径是指在有向图中从起点到终点的最长路径，这条路径上的活动被称为关键活动。关键路径代表了完成整个项目所需的最长时间，而关键活动是项目中时间安排上不可压缩的任务，即任何一个关键活动的延迟都将导致整个项目延期。</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树（Huffman Tree），也被称为最优二叉树，是一种特殊的二叉树结构，它在数据压缩、编码以及通信领域有广泛的应用。主要用于有效编码，以减少数据传输过程中的总位数或存储数据时所需的空间。</p>
<h4 id="哈夫曼树的特点："><a href="#哈夫曼树的特点：" class="headerlink" title="哈夫曼树的特点："></a>哈夫曼树的特点：</h4><ol>
<li><strong>最优二叉树</strong>：在所有可能的二叉树中，哈夫曼树的加权路径长度（WPL，即树中所有叶子节点的权值与其路径长度乘积之和）最小，因此也被称为最优二叉树。</li>
<li><strong>贪心算法构建</strong>：哈夫曼树的构建是通过贪心算法实现的。从底向上的构建过程中，每一步都选择两个权值最小的树合并，直到所有的树合并成一棵树。</li>
<li><strong>叶子节点存放数据</strong>：在哈夫曼树中，所有用于表示数据的节点都是叶子节点，且每个叶子节点都代表一个数据或字符，其权值通常是该数据在序列中出现的频率。</li>
<li><strong>无歧义编码</strong>：由哈夫曼树生成的编码是前缀码，即任何字符的编码都不是另一个字符编码的前缀，这消除了编码的歧义性，确保了编码的唯一解码性。</li>
<li><strong>动态调整</strong>：虽然哈夫曼树对一个给定的数据集是最优的，但如果数据集变化，原有的哈夫曼树可能不再是最优的。因此，在实际应用中，可能需要对哈夫曼树进行动态调整。</li>
</ol>
<p>哈夫曼树的应用非常广泛，特别是在数据压缩（如ZIP文件格式）和编码通信领域。通过减少无用信息的存储和传输，哈夫曼编码显著提高了数据处理的效率。</p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="Cache-是什么，为什么用-cache，原理-有几种映射方式"><a href="#Cache-是什么，为什么用-cache，原理-有几种映射方式" class="headerlink" title="Cache 是什么，为什么用 cache，原理,有几种映射方式"></a>Cache 是什么，为什么用 cache，原理,有几种映射方式</h3><p>Cache（缓存）是一种高速数据存储层，其目的是临时存储一部分数据，这些数据在短时间内可能会被再次访问。使用缓存可以减少访问原始数据源（如硬盘或远程服务器）的次数，从而显著提高数据访问的速度和系统整体的性能。</p>
<h3 id="为什么使用Cache"><a href="#为什么使用Cache" class="headerlink" title="为什么使用Cache?"></a>为什么使用Cache?</h3><p>减少延迟：访问缓存数据比访问主存储（如硬盘）快得多，这有助于减少程序执行的延迟时间。<br>降低后端负载：通过减少对后端服务器的直接请求，可以显著降低服务器的负载，提高系统的扩展性和稳定性。<br>提高性能：缓存经常访问的数据可以显著提高应用程序的响应速度和整体性能。</p>
<h3 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a>缓存的原理</h3><p>缓存工作的基本原理是数据的局部性原理，即在短时间内，程序访问的数据和指令往往局限于某个局部区域。这包括：</p>
<p>时间局部性：如果一个数据被访问，那么在不久的将来它可能被再次访问。<br>空间局部性：如果一个数据被访问，那么它附近的数据也很可能被访问。</p>
<h3 id="缓存的映射方式"><a href="#缓存的映射方式" class="headerlink" title="缓存的映射方式"></a>缓存的映射方式</h3><p>缓存中的数据是如何映射和存储的关键问题之一。有三种基本的映射方式：</p>
<p>直接映射（Direct Mapped Cache）</p>
<p>每个块只有一个固定的位置，通过地址的某些位直接决定。<br>实现简单，成本低，但可能出现高冲突率。<br>全相联映射（Fully Associative Cache）</p>
<p>任何块可以放在缓存中的任何位置。<br>查找灵活，不容易冲突，但成本高，查找时间长。<br>组相联映射（Set Associative Cache）</p>
<p>折中方案，缓存被分为几个组，每个块根据地址的某些位被映射到一个组，但在这个组内部可以放在任何位置。<br>结合了直接映射和全相联映射的优点，通过调整组的大小和数量可以平衡查找时间和冲突率。<br>通过这些映射方式，缓存可以有效地存储和检索数据，从而提高数据访问的速度和效率。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ol>
<li><strong>基本概念</strong>:<ul>
<li><strong>进程（Process）</strong>：是操作系统进行资源分配和调度的一个独立单位，是应用程序的一次执行活动。每个进程都有自己独立的地址空间、内存、数据栈以及其他记录其运行轨迹的辅助数据。进程间通信需要通过进程间通信机制（IPC）来实现，如管道、信号、套接字、共享内存等。</li>
<li><strong>线程（Thread）</strong>：是进程中的一个实体，被系统独立调度和分派的基本单位。一个进程可以包含多个线程，它们共享进程的地址空间和资源，但每个线程有自己的执行栈和程序计数器。线程间的通信和数据共享更简单，因为它们共享相同的进程资源。</li>
</ul>
</li>
<li><strong>资源管理</strong>:<ul>
<li><strong>进程</strong>：拥有完全独立的资源，进程间资源不共享，切换代价大，资源消耗较多。</li>
<li><strong>线程</strong>：同一进程内的线程共享进程资源，如内存和文件描述符等，线程切换代价小，资源消耗较少。</li>
</ul>
</li>
<li><strong>执行流</strong>:<ul>
<li><strong>进程</strong>：每个进程都有独立的执行流，进程间互不干扰。</li>
<li><strong>线程</strong>：同一进程内的多个线程可并发执行，共享相同的执行环境。</li>
</ul>
</li>
<li><strong>通信方式</strong>:<ul>
<li><strong>进程</strong>：由于进程间资源独立，它们之间的通信需要使用操作系统提供的进程间通信机制。</li>
<li><strong>线程</strong>：由于共享进程资源，线程间通信更为方便，可以直接通过读写进程数据段中的数据来进行。</li>
</ul>
</li>
<li><strong>系统开销</strong>:<ul>
<li><strong>进程</strong>：创建和销毁进程的系统开销大，上下文切换时间长。</li>
<li><strong>线程</strong>：创建和销毁线程的系统开销小，上下文切换时间短，效率高。</li>
</ul>
</li>
</ol>
<h3 id="死锁的产生和避免"><a href="#死锁的产生和避免" class="headerlink" title="死锁的产生和避免?"></a>死锁的产生和避免?</h3><p>死锁的四个必要条件：<br>(1)互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。<br>(2)请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。<br>(3)非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。<br>(4)循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</p>
<p>　死锁避免（deadlock avoidence）是在系统运行过程中注意避免死锁的发生。这就要求每当申请一个资源时，系统都应根据一定的算法判断是否认可这次申请，使得在今后一段时间内系统不会出现死锁。这面方最著名的算法首推Dijkstra[1965]提出的银行家（banker）算法。</p>
<h3 id="串行总线和并行总线的区别"><a href="#串行总线和并行总线的区别" class="headerlink" title="串行总线和并行总线的区别"></a>串行总线和并行总线的区别</h3><p>串行总线和并行总线的主要区别在于数据传输方式。串行总线在单一通道上逐位顺序传输数据，占用的线路少，但传输速度受限于单个通道的速率，常见于USB、SATA等接口。并行总线同时在多个通道上传输数据，理论上可以提供更高的传输速度，但随着传输距离的增加，易受到信号干扰和时钟同步的挑战，典型应用包括早期的IDE接口和计算机内部的数据总线。随着技术进步，高速串行总线因其较高的信号完整性和扩展性而越来越受到青睐。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="Q：五层协议的体系结构分别是什么？每一层都有哪些协议？"><a href="#Q：五层协议的体系结构分别是什么？每一层都有哪些协议？" class="headerlink" title="Q：五层协议的体系结构分别是什么？每一层都有哪些协议？"></a>Q：五层协议的体系结构分别是什么？每一层都有哪些协议？</h3><p><strong>应用层</strong>：应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，还要作为互相作用的应用进程的用户代理（user agent)；<br>HTTP（超文本传输协议）：用于网页数据的传输。<br>FTP（文件传输协议）：用于文件的传输。<br>SMTP（简单邮件传输协议）：用于发送电子邮件。<br>DNS（域名系统）：用于解析域名到IP地址。</p>
<p><strong>运输层</strong>：负责主机中两个进程间的通信；<br>TCP（传输控制协议）：提供面向连接的、可靠的数据传输服务。<br>UDP（用户数据报协议）：提供无连接的、尽最大努力交付的数据传输服务。</p>
<p><strong>网络层</strong>：负责为分组选择合适的路由；<br>IP（互联网协议）：是用于路由选择的核心协议。<br>ICMP（互联网控制消息协议）：用于传递控制消息。<br>ARP（地址解析协议）：用于将网络地址转换为物理地址。</p>
<p><strong>数据链路层</strong>：将在网络层交下来的数据报组装成帧（frame)，两个相邻结点间的链路实现帧的传输；<br>PPP（点对点协议）：用于直接连接两个网络节点。</p>
<p><strong>物理层</strong>：透明地传输比特流。物理层不涉及协议，而是定义了电气信号、线路标准和网络设备的物理规格 </p>
<h3 id="Q：为何有MAC地址还要IP地址？"><a href="#Q：为何有MAC地址还要IP地址？" class="headerlink" title="Q：为何有MAC地址还要IP地址？"></a>Q：为何有MAC地址还要IP地址？</h3><p>基本上一个观点就是一个是物理地址，一个是逻辑地址。</p>
<p>假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络。</p>
<p> 然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。</p>
<p>如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。</p>
<p>电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。</p>
<p>话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="Q：TCP和UDP的区别？"><a href="#Q：TCP和UDP的区别？" class="headerlink" title="Q：TCP和UDP的区别？"></a>Q：TCP和UDP的区别？</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<h3 id="Q：拥塞控制和流量控制都是什么，两者的区别？"><a href="#Q：拥塞控制和流量控制都是什么，两者的区别？" class="headerlink" title="Q：拥塞控制和流量控制都是什么，两者的区别？"></a>Q：拥塞控制和流量控制都是什么，两者的区别？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/53716367">https://blog.csdn.net/ailunlee/article/details/53716367</a></p>
<p>流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。<br>拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</p>
<h3 id="Q：谈谈TCP为什么要三次握手？为什么要四次挥手？"><a href="#Q：谈谈TCP为什么要三次握手？为什么要四次挥手？" class="headerlink" title="Q：谈谈TCP为什么要三次握手？为什么要四次挥手？"></a>Q：谈谈TCP为什么要三次握手？为什么要四次挥手？</h3><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>三次握手（SYN, SYN-ACK, ACK）的目的是可靠地建立两个TCP端点之间的连接。它确保双方都知道对方的接收和发送能力是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：客户端发送SYN包（同步序列编号）到服务器以开始新连接。</li>
<li><strong>第二次握手</strong>：服务器回应一个SYN-ACK包，确认收到客户端的SYN。</li>
<li><strong>第三次握手</strong>：客户端再次发送ACK包响应，确认收到服务器的SYN-ACK。</li>
</ol>
<p>这种机制确保了双方都能确认自己和对方的发送和接收是正常的，避免了初始化连接的不确定性和资源浪费。</p>
<h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>四次挥手（FIN, ACK, FIN, ACK）的目的是可靠地终止两个TCP端点之间的连接。因为TCP连接是全双工的，即数据可以在两个方向上流动，所以每个方向都必须单独进行关闭。</p>
<ol>
<li><strong>第一次挥手</strong>：当通信的一方完成数据发送任务后，发送一个FIN包，请求关闭连接。</li>
<li><strong>第二次挥手</strong>：另一方确认收到FIN包，回送一个ACK包。</li>
<li><strong>第三次挥手</strong>：另一方也发送一个FIN包，请求关闭另一方向的连接。</li>
<li><strong>第四次挥手</strong>：最初请求关闭连接的一方确认收到另一方的FIN包，回送一个ACK包。</li>
</ol>
<p>这种分步关闭机制确保了数据在连接关闭前能完整传输，且双方都清楚连接何时完全关闭，从而优雅地关闭连接，释放资源。</p>
<h3 id="Q：播放视频用TCP还是UDP？为什么？"><a href="#Q：播放视频用TCP还是UDP？为什么？" class="headerlink" title="Q：播放视频用TCP还是UDP？为什么？"></a>Q：播放视频用TCP还是UDP？为什么？</h3><p>播放视频时，既可以使用TCP也可以使用UDP，选择哪一个取决于应用场景的具体需求和优先级。</p>
<h4 id="使用TCP的情况："><a href="#使用TCP的情况：" class="headerlink" title="使用TCP的情况："></a>使用TCP的情况：</h4><ul>
<li><strong>需求强调数据的完整性和可靠性</strong>：如果视频播放的应用场景对数据传输的完整性和可靠性有很高的要求，比如点播服务、文件下载，或需要确保每一帧数据都不丢失且完整到达，那么应该使用TCP。</li>
<li><strong>自适应网络条件的能力</strong>：TCP有拥塞控制和流量控制机制，能根据网络状况自动调整数据传输速率，避免网络拥堵。</li>
</ul>
<h4 id="使用UDP的情况："><a href="#使用UDP的情况：" class="headerlink" title="使用UDP的情况："></a>使用UDP的情况：</h4><ul>
<li><strong>需求强调实时性和低延迟</strong>：如果视频播放更注重流畅度和低延迟，比如直播或实时视频会议，UDP更为合适。UDP不需要进行连接的建立和维护，也不会因为数据重传而增加额外的延迟。</li>
<li><strong>允许数据丢失</strong>：UDP不保证数据的可靠性，少量数据包的丢失可以通过应用层的一些策略来弥补，如错误恢复技术和冗余发送关键数据。</li>
</ul>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li><strong>对于点播系统</strong>，倾向于选择TCP，因为它需要数据的完整性和可靠性更高。</li>
<li><strong>对于直播系统</strong>，倾向于使用UDP，因为它对实时性的要求更高，而且可以容忍一定程度的数据丢失。</li>
</ul>
<h3 id="Q：HTTP报文格式？"><a href="#Q：HTTP报文格式？" class="headerlink" title="Q：HTTP报文格式？"></a>Q：HTTP报文格式？</h3><p>请求报文由三部分组成：请求行、请求头部（Header）、消息主体（可选部分，包含发送的数据。对于GET请求通常为空，POST请求中通常包含表单数据或要上传的内容）。</p>
<p>响应报文由三部分组成：状态行、响应头部（Header）、消息主体。</p>
<h3 id="Q：了解哪些响应状态码？"><a href="#Q：了解哪些响应状态码？" class="headerlink" title="Q：了解哪些响应状态码？"></a>Q：了解哪些响应状态码？</h3><p>http状态返回代码 1xx（临时响应）：表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>http状态返回代码 2xx （成功）：表示成功处理了请求的状态代码。</p>
<p>http状态返回代码 3xx （重定向）：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p>http状态返回代码 4xx（请求错误）：这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>http状态返回代码 5xx（服务器错误）：这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<h3 id="Q：Http1-0、Http1-1、Http2-0的区别？"><a href="#Q：Http1-0、Http1-1、Http2-0的区别？" class="headerlink" title="Q：Http1.0、Http1.1、Http2.0的区别？"></a>Q：Http1.0、Http1.1、Http2.0的区别？</h3><p>HTTP/1.0、HTTP/1.1 和 HTTP/2.0 是HTTP协议的三个主要版本</p>
<p>HTTP/1.0无连接复用：每次请求/响应后都会关闭TCP连接，再次请求需要重新建立连接。</p>
<p>HTTP/1.1<strong>连接复用</strong>：默认情况下，TCP连接在多个请求之间保持打开状态，减少了建立连接的开销。</p>
<p>HTTP/2.0<strong>流和多路复用</strong>：在单一连接中同时发送多个请求和响应，请求和响应可以分成独立的帧，这些帧交错发送并在另一端重新组装。</p>
<p>简而言之，HTTP/1.1 相对于 HTTP/1.0 主要增加了连接复用和虚拟主机支持，而 HTTP/2.0 在此基础上进一步引入了二进制分帧、流和多路复用、头部压缩和服务器推送等高效的新特性，大大提高了Web性能和效率。</p>
<h3 id="Q：HTTP和TCP的区别"><a href="#Q：HTTP和TCP的区别" class="headerlink" title="Q：HTTP和TCP的区别?"></a>Q：HTTP和TCP的区别?</h3><p>  HTTP是应用层的协议，主要规定了客户端和服务器之间的通信格式和规则，用于传输超文本等数据。TCP是传输层的协议，提供可靠的、面向连接的通信服务，确保数据的正确传输。简而言之，HTTP依赖于TCP来实现在网络中的数据传输，TCP为HTTP提供支持，但二者工作在不同的网络模型层级，解决不同的通信问题。HTTP关注数据内容的结构和表示，而TCP关注于数据包的准确送达。</p>
<h3 id="Q：HTTP和HTTPS的区别"><a href="#Q：HTTP和HTTPS的区别" class="headerlink" title="Q：HTTP和HTTPS的区别?"></a>Q：HTTP和HTTPS的区别?</h3><p>HTTP和HTTPS的主要区别在于安全性。HTTPS是HTTP的安全版本，它在传输数据时通过SSL/TLS协议进行加密，保护数据免受中间人攻击，确保数据传输的安全性和完整性。HTTP传输数据不加密，容易被窃听或篡改。HTTPS默认使用443端口，而HTTP使用80端口。虽然HTTPS提高了安全性，但加密解密过程增加了计算开销，可能会稍微影响性能。</p>
<h3 id="Q：HTTP和Socket的区别"><a href="#Q：HTTP和Socket的区别" class="headerlink" title="Q：HTTP和Socket的区别?"></a>Q：HTTP和Socket的区别?</h3><p>Socket是网络编程中的一个接口（API），提供创建网络应用的方式，支持TCP/UDP协议，实现端到端的数据通信。Socket更为底层，可以用于构建各种协议，包括HTTP。</p>
<p>Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。</p>
<h3 id="Q：在地址栏打入http-www-baidu-com会发生什么？"><a href="#Q：在地址栏打入http-www-baidu-com会发生什么？" class="headerlink" title="Q：在地址栏打入http://www.baidu.com会发生什么？"></a>Q：在地址栏打入<a href="http://www.baidu.com会发生什么？">http://www.baidu.com会发生什么？</a></h3><ol>
<li><strong>域名解析</strong>：用户在浏览器地址栏输入网站域名，如<code>www.example.com</code>。浏览器首先查询本地DNS缓存，若未找到，向配置的DNS服务器发起解析请求，将域名解析为服务器的IP地址。</li>
<li><strong>建立连接</strong>：浏览器使用解析得到的IP地址，通过TCP协议（通常基于TCP的HTTP或HTTPS协议）发起对服务器的连接请求。若是HTTPS，还需进行TLS握手，建立加密通道。</li>
<li><strong>发送HTTP请求</strong>：一旦TCP连接建立，浏览器就构建一个HTTP请求消息，包含请求行（如<code>GET / HTTP/1.1</code>）、请求头（如<code>Host: www.example.com</code>、<code>User-Agent: Mozilla/5.0</code>等）和请求体（如果有的话），并发送给服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到HTTP请求后，根据请求的资源路径（URL），调用后端程序处理请求。处理过程可能涉及查询数据库、执行后端逻辑等操作。</li>
<li><strong>发送HTTP响应</strong>：服务器处理完请求后，会构建一个HTTP响应消息，包含状态行（如<code>HTTP/1.1 200 OK</code>）、响应头（如<code>Content-Type: text/html</code>）和响应体（即实际的资源内容），并发送回客户端。</li>
<li><strong>渲染页面</strong>：浏览器接收到HTTP响应后，根据响应体中的HTML内容开始解析和渲染页面。如果HTML中包含外部资源的链接（如CSS、JavaScript文件、图片等），浏览器会再次发起HTTP请求获取这些资源。</li>
<li><strong>关闭连接</strong>：页面及其相关资源全部加载完成后，若没有设置持久连接（HTTP/1.1中的<code>Connection: keep-alive</code>），浏览器和服务器会关闭TCP连接。</li>
</ol>
<p>整个过程涵盖了域名解析（应用层DNS协议）、建立连接（传输层TCP协议）、安全加密（TLS协议）、内容请求和传输（应用层HTTP/HTTPS协议）等多个网络层次的操作</p>
<h3 id="Q：长链接与短连接？"><a href="#Q：长链接与短连接？" class="headerlink" title="Q：长链接与短连接？"></a>Q：长链接与短连接？</h3><p>短链接就是无链接复用，每次请求/响应后都会关闭TCP连接，再次请求需要重新建立连接。</p>
<p>长连接是连接复用，默认情况下，TCP连接在多个请求之间保持打开状态，减少了建立连接的开销。</p>
<h3 id="路由器在计算机网络的哪一层？有什么功能？"><a href="#路由器在计算机网络的哪一层？有什么功能？" class="headerlink" title="路由器在计算机网络的哪一层？有什么功能？"></a>路由器在计算机网络的哪一层？有什么功能？</h3><p>路由器工作在计算机网络的，即网络层。路由器的主要功能是：</p>
<ul>
<li>路由选择：确定数据包从源到目的地的最佳路径。</li>
<li>分组转发：根据路由选择的路径转发数据包到下一个网络段或目的地。</li>
<li>子网流量管理：控制网络流量，避免网络拥塞。</li>
<li>网络互连：连接不同的网络技术，如以太网和Wi-Fi。</li>
<li>数据包过滤和安全控制：可能包括防火墙功能，对通过的数据包进行过滤。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Q：数据库中的事务了解吗？事务的四大特性？"><a href="#Q：数据库中的事务了解吗？事务的四大特性？" class="headerlink" title="Q：数据库中的事务了解吗？事务的四大特性？"></a>Q：数据库中的事务了解吗？事务的四大特性？</h3><p>数据库事务是数据库运行中的逻辑工作单位，单个逻辑工作单元所执行的一系列操作，要么都执行，要么都不执行。例如银行取款事务分为2个步骤(1)存折减款(2)提取现金，2个步骤必须同时完成或者都不完成。</p>
<p>数据库事务的四大特性（ACID)：</p>
<p>(1) 原子性(Atomicity)：<br>     事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br>(2)一致性(Consistency) ：<br>    事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。<br>(3)分离性(Isolation)：<br>   分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。<br>(4)持久性(Durability)：<br>   持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</p>
<h3 id="Q：如何理解数据库的范式？"><a href="#Q：如何理解数据库的范式？" class="headerlink" title="Q：如何理解数据库的范式？"></a>Q：如何理解数据库的范式？</h3><p>第一范式（1NF）：确保每一列的原子性</p>
<p>如果每一列都是不可再分的最小数据单元，则满足第一范式。</p>
<p>第二范式:非键字段必须依赖于键字段</p>
<p>如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。</p>
<p>第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性</p>
<p>（在2NF基础上消除传递依赖）</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>尊敬的各位老师，上午/下午好！我非常荣幸能够参加今天的面试，并见到在座的各位。我是xx，今年xx岁，来自xxx。本科毕业于xx大学xx专业。今天，我希望通过三个方面来介绍我自己：学习经历、实践经验和未来的读研规划。</p>
<p>在学习经历方面，我始终保持着积极进取的学习态度，对计算机科学领域充满热情。本科期间，我系统学习了数据结构、操作系统、计算机网络等核心课程，这为我奠定了扎实的专业基础并深化了我的兴趣。</p>
<p>关于实践经验，我积极参与校内外的多项活动，特别是加入了学校环保社团并积极参与流浪动物领养日活动，这不仅让我学会了责任和同情心，也锻炼了我的组织和沟通能力。在科研方面，我选择了我深感兴趣的爬虫技术作为毕业论文的主题，通过全面的文献调研和实践操作，我不仅提升了研究和解决问题的能力，也坚定了我继续深造的决心。</p>
<p>展望未来，我希望能有机会加入贵校，继续在计算机科学与技术领域深造。我计划在深入学习专业知识的同时，培养研究能力和创新思维。我将努力参与学术论文的撰写和发表，通过不断阅读和研究，提高我的科研水平。同时，我也希望能参与导师的研究项目，通过团队合作和学术交流，拓宽我的视野，并全面提升我的学术及实践能力。</p>
<p>感谢各位老师的聆听。我期待着能在贵校获得更多的学习和成长机会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://bigshuimu.github.io/2024/01/17/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%82%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
      <meta itemprop="name" content="水木君">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水木君的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%82%92/" class="post-title-link" itemprop="url">算法小炒</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 13:14:08" itemprop="dateCreated datePublished" datetime="2024-01-17T13:14:08+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-28 16:49:42" itemprop="dateModified" datetime="2024-03-28T16:49:42+08:00">2024-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><img src="/2024/01/17/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%82%92/image-20240117131741668.png" class="" title="image-20240117131741668">
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/17/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%82%92/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://bigshuimu.github.io/2024/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
      <meta itemprop="name" content="水木君">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水木君的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">数据结构代码实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-11 16:38:17" itemprop="dateCreated datePublished" datetime="2024-01-11T16:38:17+08:00">2024-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 16:37:27" itemprop="dateModified" datetime="2024-01-21T16:37:27+08:00">2024-01-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考书目：高一凡书，严蔚敏书</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="水木君"
      src="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
  <p class="site-author-name" itemprop="name">水木君</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigshuimu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigshuimu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://armke.github.io/" title="https:&#x2F;&#x2F;armke.github.io&#x2F;" rel="noopener" target="_blank">armke</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">水木君</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
