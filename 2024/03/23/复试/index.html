<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png">
  <link rel="mask-icon" href="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bigshuimu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="项目前后端交互的方式Fetch API 是一种现代、强大的网络请求API，它提供了一个JavaScript接口，用于访问和操作HTTP管道的部分，例如请求和响应。它提供了一个全局 fetch() 方法，该方法提供了一种简单、合理的方式来异步获取资源网络上的资源。Fetch API 允许你通过第二个参数自定义请求的许多方面，包括HTTP方法、头部、body等： get和post的区别? 数据传输方式">
<meta property="og:type" content="article">
<meta property="og:title" content="复试">
<meta property="og:url" content="https://bigshuimu.github.io/2024/03/23/%E5%A4%8D%E8%AF%95/index.html">
<meta property="og:site_name" content="水木君的个人博客">
<meta property="og:description" content="项目前后端交互的方式Fetch API 是一种现代、强大的网络请求API，它提供了一个JavaScript接口，用于访问和操作HTTP管道的部分，例如请求和响应。它提供了一个全局 fetch() 方法，该方法提供了一种简单、合理的方式来异步获取资源网络上的资源。Fetch API 允许你通过第二个参数自定义请求的许多方面，包括HTTP方法、头部、body等： get和post的区别? 数据传输方式">
<meta property="og:locale">
<meta property="article:published_time" content="2024-03-23T07:57:02.000Z">
<meta property="article:modified_time" content="2024-04-09T22:28:44.193Z">
<meta property="article:author" content="水木君">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bigshuimu.github.io/2024/03/23/%E5%A4%8D%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>复试 | 水木君的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">水木君的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://bigshuimu.github.io/2024/03/23/%E5%A4%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
      <meta itemprop="name" content="水木君">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水木君的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          复试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-23 15:57:02" itemprop="dateCreated datePublished" datetime="2024-03-23T15:57:02+08:00">2024-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-10 06:28:44" itemprop="dateModified" datetime="2024-04-10T06:28:44+08:00">2024-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="前后端交互的方式"><a href="#前后端交互的方式" class="headerlink" title="前后端交互的方式"></a>前后端交互的方式</h3><p>Fetch API 是一种现代、强大的网络请求API，它提供了一个JavaScript接口，用于访问和操作HTTP管道的部分，例如请求和响应。它提供了一个全局 <code>fetch()</code> 方法，该方法提供了一种简单、合理的方式来异步获取资源网络上的资源。Fetch API 允许你通过第二个参数自定义请求的许多方面，包括HTTP方法、头部、body等：</p>
<h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别?"></a>get和post的区别?</h3><ol>
<li><strong>数据传输方式</strong>：<ul>
<li><strong>GET</strong>：将请求数据附加在 URL 之后，以查询字符串的形式出现。由于浏览器和服务器对 URL 长度有限制，因此能发送的数据量较小。</li>
<li><strong>POST</strong>：将请求数据放在 HTTP 请求的 body 中，不会暴露在 URL 上。理论上可以发送更多的数据。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li><strong>GET</strong>：由于数据在 URL 中可见，因此不适合发送敏感信息。</li>
<li><strong>POST</strong>：数据不会显示在 URL 中，相对更安全，适合发送敏感信息。</li>
</ul>
</li>
<li><strong>幂等性</strong>：<ul>
<li><strong>GET</strong>：是幂等的，意味着多次执行同一请求，资源的状态不会改变。</li>
<li><strong>POST</strong>：不是幂等的，每次请求都可能修改服务器上的资源状态。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li><strong>GET</strong>：用于请求数据，如查询、搜索等。</li>
<li><strong>POST</strong>：用于提交数据到服务器，如表单提交。</li>
</ul>
</li>
<li><strong>缓存</strong>：<ul>
<li><strong>GET</strong>：请求可以被缓存。(浏览器可以直接从缓存中加载这些资源，而不是再次从服务器请求它们)</li>
<li><strong>POST</strong>：请求默认不被缓存。</li>
</ul>
</li>
</ol>
<h3 id="极客商城是一个什么样的项目"><a href="#极客商城是一个什么样的项目" class="headerlink" title="极客商城是一个什么样的项目"></a>极客商城是一个什么样的项目</h3><p>极客商城是一个专门针对手机端用户设计的web商城项目，。通过精心的设计和开发，极客商城实现了商品的展示、购买、管理等核心功能，同时也提供了购物车、用户评论、商品搜索等辅助功能，以增强用户的购物体验和便利性。</p>
<p>在技术实现方面，极客商城采用了当下流行的前端技术栈，包括HTML、CSS和JavaScript，确保了页面的响应速度和交互体验。特别是使用了Vue 2框架，它以数据驱动和组件化的开发思想，帮助开发者高效地构建动态的用户界面。此外，项目还采用了uni-app框架，这是一个使用Vue.js开发所有前端应用的框架，它允许开发者编写一次代码，就可以发布到iOS、Android、Web等多个平台，极大地提高了开发效率和项目的可维护性。</p>
<p>在后端技术上，极客商城基于Node.js进行开发，Node.js是一个基于Chrome V8引擎的JavaScript运行环境，它使得JavaScript可以脱离浏览器环境，直接在服务器端运行。这种技术选择不仅使得前后端开发语言统一，而且Node.js的非阻塞I/O和事件驱动的特性，也让极客商城的服务器能够处理大量并发请求，保证了商城系统的高性能和稳定性。</p>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>XPath，全称为XML Path Language，是一种在XML文档中查找信息的语言。它被设计用来遍历和处理XML文档的结构，允许开发者编写查询，从而定位到文档中特定的元素、属性或者文本内容。由于XML的结构和HTML非常相似，XPath也经常被用于对HTML文档进行查询，尤其在Web爬虫和一些需要解析HTML文档的应用中十分常见。</p>
<ul>
<li><strong>节点选择</strong>：<code>/</code>表示从根节点开始选择，<code>//</code>可以从任何位置开始搜索匹配的节点。</li>
<li><strong>属性选择</strong>：<code>@</code>用于选择属性。例如，<code>//book[@lang=&#39;en&#39;]</code>选择所有<code>lang</code>属性为<code>en</code>的<code>book</code>元素。</li>
<li><strong>谓词</strong>：方括号<code>[]</code>用于提供谓词，精确地过滤节点。例如，<code>//book[price&gt;35.00]</code>选择所有<code>price</code>元素值大于35.00的<code>book</code>元素。</li>
<li><strong>通配符</strong>：<code>*</code>表示匹配任何元素节点，例如，<code>//*</code>选择文档中的所有元素。</li>
<li><strong>轴</strong>：定义了节点和其他节点之间的树关系，如<code>ancestor</code>、<code>child</code>、<code>descendant</code>等。例如，<code>//title/ancestor::book</code>选择所有<code>title</code>元素的<code>book</code>祖先元素。</li>
</ul>
<h3 id="vue2的特点，相对于传统js有何区别？"><a href="#vue2的特点，相对于传统js有何区别？" class="headerlink" title="vue2的特点，相对于传统js有何区别？"></a>vue2的特点，相对于传统js有何区别？</h3><ol>
<li><p><strong>响应式数据绑定</strong>：</p>
<ul>
<li>Vue 2使用双向数据绑定，意味着将JavaScript对象与UI绑定起来，当数据发生变化时，界面会自动更新。这使得状态管理变得简单直观。</li>
</ul>
</li>
<li><p><strong>组件化</strong>：</p>
<ul>
<li>应用被划分为可重用的组件，每个组件包含自己的模板、逻辑和样式。这种模块化的方式提高了代码的复用性和测试性。</li>
</ul>
</li>
<li><p><strong>虚拟DOM</strong>：</p>
<ul>
<li>Vue 2使用虚拟DOM来优化渲染过程。通过比较新旧虚拟DOM的差异，Vue可以仅更新必要的DOM元素，而不是重绘整个页面，从而提高性能。</li>
</ul>
</li>
</ol>
<h3 id="解释TSBased-AEXPath算法"><a href="#解释TSBased-AEXPath算法" class="headerlink" title="解释TSBased-AEXPath算法"></a>解释TSBased-AEXPath算法</h3><ol>
<li><strong>加载网页内容</strong>：使用Selenium加载动态网页，获取页面源代码。</li>
<li><strong>解析HTML为树结构</strong>：使用<code>lxml</code>解析页面源代码，构建树形结构。</li>
</ol>
<p>通常情况下同一站点内的不同详情页面基本 框架结构一致，除去广告内容和链接等相同内容， 剩下不同部分通常是有效内容部分。可以等价的说， 同一站点(或同一站点内的某一个模块)的不同页面 的网页内容在提取过程中通常有效 Xpath 都分布在 这些 Xpath 路径相同但对应内容不同的 Xpath 中。</p>
<h3 id="介绍一下redis，对比mysql的区别"><a href="#介绍一下redis，对比mysql的区别" class="headerlink" title="介绍一下redis，对比mysql的区别"></a>介绍一下redis，对比mysql的区别</h3><p>Redis<br>Redis 是一个开源的内存中数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串、哈希、列表、集合、有序集合等。Redis 的主要特点是其高性能和低延迟，它通过将数据存储在内存中来实现快速的读写速度。</p>
<p>MySQL<br>MySQL 是一个开源的关系数据库管理系统，它使用表格结构来组织数据，并通过 SQL（结构化查询语言）进行访问和管理。MySQL 适用于存储结构化数据，它通过事务支持、ACID（原子性、一致性、隔离性、持久性）保证等功能来提供数据的完整性和可靠性。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h3><p>是数据结构中的一种逻辑结构，是n个具有相同特性的数据元素的有限序列。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是一种二叉搜索树，其中任何节点的两个子树的高度差不超过1。这种平衡条件确保树保持较低的高度，从而在进行插入、删除和查找操作时保持较高的性能，即操作的时间复杂度保持在O(log n)，其中n是树中节点的数量。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序的基本思想是持续地选择入度为0的节点（即没有任何其他节点指向它的节点），将其从图中移除，并从图中移除以该节点为起点的所有边。重复这个过程，直到图中没有节点，或者图中剩余的节点中没有入度为0的节点（这意味着图中存在环，因此无法进行拓扑排序）</p>
<h3 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h3><p>m 阶的B+树与m阶的B树的主要差异如下：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在<br>B 树中，具有n个关键字的结点含有n+1棵子树。<br>2）在B+树中，每个结点（非根内部结点）的关键字个数n的范围是m/2≤n≤m（根结点：<br>2≤n≤m）；在B树中，每个结点（非根内部结点）的关键字个数n的范围是m/2-1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；<br>而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。</p>
<h3 id="怎么理解数据结构"><a href="#怎么理解数据结构" class="headerlink" title="怎么理解数据结构"></a>怎么理解数据结构</h3><p>数据结构是计算机存储、组织数据的方式，它不仅包括数据元素的集合，还包括数据元素之间的关系及操作。通过合理的数据结构可以高效地存取和处理数据。常见的数据结构有数组、栈、队列、链表、树、图等，每种结构有其特定的用途和优势，选择合适的数据结构是解决问题和优化程序性能的关键。</p>
<h3 id="迭代和递归的特点，并比较优缺点"><a href="#迭代和递归的特点，并比较优缺点" class="headerlink" title="迭代和递归的特点，并比较优缺点"></a>迭代和递归的特点，并比较优缺点</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>程序调用自身的编程技巧称为递归</p>
<p>1）大问题化为小问题,可以极大的减少代码量；</p>
<p>2）用有限的语句来定义对象的无限集合.；</p>
<p>3）代码更简洁清晰，可读性更好</p>
<p>1）递归调用函数,浪费空间；</p>
<p>2）递归太深容易造成堆栈的溢出；</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B.</p>
<p>1）迭代效率高，运行时间只因循环次数增加而增加；</p>
<p>2）没什么额外开销，空间上也没有什么增加，</p>
<p>1） 不容易理解；</p>
<p>2） 代码不如递归简洁；</p>
<p>3） 编写复杂问题时困难。</p>
<p>二者关系</p>
<p>1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。</p>
<p>2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>查找</th>
<th>平均时间复杂度</th>
<th>查找条件</th>
<th>算法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找</td>
<td>O<sub>(n)<sub/></td>
<td>无序或有序队列</td>
<td>按顺序比较每个元素，直到找到关键字为止</td>
</tr>
<tr>
<td>二分查找（折半查找）</td>
<td>O<sub>(logn)<sub/></td>
<td>有序数组</td>
<td>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</td>
</tr>
<tr>
<td>二叉排序树查找</td>
<td>O<sub>(logn)<sub/></td>
<td>二叉排序树</td>
<td>在二叉查找树b中查找x的过程为：1．若b是空树，则搜索失败二叉排序树查找2．若x等于b的根节点的数据域之值，则查找成功；3．若x小于b的根节点的数据域之值，则搜索左子树4．查找右子树。</td>
</tr>
<tr>
<td>哈希表法（散列表）</td>
<td>O<sub>(1)<sub/></td>
<td>先创建哈希表（散列表）</td>
<td>根据键值方式（Key value）进行查找，通过散列函数，定位数据元素</td>
</tr>
<tr>
<td>分块查找</td>
<td>O<sub>(logn)<sub/></td>
<td>无序或有序队列</td>
<td>将n个数据元素＂按块有序”划分为m块（m≤n）。每一块中的结点不必有序，但块与块之间必须“按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…….然后使用二分查找及顺序查找。</td>
</tr>
</tbody>
</table>
</div>
<p>哈希表（散列表）：<br>适用场景：数据量大，需快速查找、插入和删除。<br>缺点：在最坏情况下（所有元素都映射到同一个槽）时间复杂度退化为 O(n)；不适合范围查找。</p>
<p>二叉搜索树（尤其是平衡二叉搜索树如AVL树、红黑树）：<br>适用场景：需要快速查找、插入和删除，同时保持数据有序。<br>优点：查找、插入和删除操作的时间复杂度平均为<br>缺点：维护成本高，需要额外的旋转操作来保持平衡。</p>
<p>B树和B+树（数据库和文件系统中常用）：<br>适用场景：大量数据存储在外部存储器（如硬盘）上时。<br>优点：减少磁盘I/O次数，提高存取效率。<br>缺点：实现复杂。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>排序法</th>
<th>最差时间复杂度</th>
<th>平均时间复杂度</th>
<th>稳定度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉树</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不一定</td>
<td>O(n)</td>
</tr>
<tr>
<td>快速</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定</td>
<td>O(log<sub>2</sub>n) ~O(n)</td>
</tr>
<tr>
<td>堆</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>希尔</td>
<td>-</td>
<td>-</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>稳定</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h3><p>（升序）以某个记录的关键字为划分元，将整个数据分为两组，左边的数据小于等于划分元，右边的数据大于等于划分元。对左右两组数据，再各自选择一个划分元，将两组数据划分为更小的序列，这样一直进行下去，直到整个序列有序。</p>
<h3 id="程序和软件有何不同"><a href="#程序和软件有何不同" class="headerlink" title="程序和软件有何不同"></a>程序和软件有何不同</h3><p>程序和软件的区别是，软件是为了完成特定的功能，解决特定的问题而用计算机语言编写的命令序列集合，可以理解为应用程序的集合。而应用程序是软件的一个组成部分，它是软件的必要元素。</p>
<h3 id="数组与链表有什么区别？"><a href="#数组与链表有什么区别？" class="headerlink" title="数组与链表有什么区别？"></a>数组与链表有什么区别？</h3><p>数组在内存中占用连续空间，支持快速随机访问，但大小固定，扩容复杂。链表由独立节点组成，每个节点指向下一个，支持灵活插入和删除操作，但访问特定元素较慢。数组适合频繁访问，链表适合频繁修改。</p>
<h3 id="度为2的树与二叉树有什么区别"><a href="#度为2的树与二叉树有什么区别" class="headerlink" title="度为2的树与二叉树有什么区别"></a>度为2的树与二叉树有什么区别</h3><p>度为2的树指的是每个节点最多有两个子节点的树，但子节点的顺序和数量不固定，可以只有一个子节点或没有。而二叉树是一种特殊的度为2的树，每个节点最多有两个子节点，且子节点有明确的左右之分。简而言之，所有二叉树都是度为2的树，但不是所有度为2的树都是二叉树。</p>
<h3 id="最小生成树有哪几种方法"><a href="#最小生成树有哪几种方法" class="headerlink" title="最小生成树有哪几种方法"></a>最小生成树有哪几种方法</h3><p>构建最小生成树的主要算法有两种：普里姆算法（Prim’s Algorithm）和克鲁斯卡尔算法（Kruskal’s Algorithm）。普里姆算法从任意顶点开始，逐步增加边，直到包含所有顶点，侧重于节点的扩展。克鲁斯卡尔算法从最小的边开始构建，逐步添加边到生成树中，直到连接所有顶点，侧重于边的选择。这两种方法都能有效找到图的最小生成树，选择哪一种取决于具体问题的特点</p>
<h3 id="时间复杂度为nlogn的排序算法有哪些？"><a href="#时间复杂度为nlogn的排序算法有哪些？" class="headerlink" title="时间复杂度为nlogn的排序算法有哪些？"></a>时间复杂度为nlogn的排序算法有哪些？</h3><p>快速排序、归并排序、堆排序</p>
<h3 id="图的存储方式有哪些？每一种方式优缺点"><a href="#图的存储方式有哪些？每一种方式优缺点" class="headerlink" title="图的存储方式有哪些？每一种方式优缺点"></a>图的存储方式有哪些？每一种方式优缺点</h3><p>图的主要存储方式有邻接矩阵和邻接表：</p>
<ul>
<li><strong>邻接矩阵</strong>：使用二维数组表示节点间的连接关系，优点是直观、访问速度快，适合表示稠密图；缺点是占用空间大，不适合稀疏图。</li>
<li><strong>邻接表</strong>：为每个节点维护一个列表，列出所有直接相连的节点，优点是空间效率高，适合稀疏图；缺点是访问特定边的速度不如邻接矩阵快。</li>
</ul>
<h3 id="图的遍历和树的遍历有哪些区别"><a href="#图的遍历和树的遍历有哪些区别" class="headerlink" title="图的遍历和树的遍历有哪些区别"></a>图的遍历和树的遍历有哪些区别</h3><p>图的遍历包括深度优先搜索（DFS）和广度优先搜索（BFS），需要特别注意避免重复访问节点，通常通过标记已访问的节点来实现。树的遍历（如前序、中序、后序和层序遍历）不需担心重复访问，因为树结构保证了每个节点只被访问一次。图的遍历更加复杂，因为图可能包含环，需要记录访问过的节点以防止无限循环；而树是一种没有环的特殊图，其遍历更直接、简单。</p>
<h3 id="二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？"><a href="#二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？" class="headerlink" title="二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？"></a>二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？</h3><p>二叉排序树（BST），又称二叉搜索树，通过将每个新插入的节点放置在正确的位置来维持元素的有序性：每个节点的左子树只包含小于节点的元素，右子树只包含大于节点的元素。这使得查找、插入和删除操作的平均时间复杂度为 O(logn)<br>O(logn)，其中 n 是树中节点的数量。</p>
<p>最好情况：树是完全平衡的，所有操作的时间复杂度为 O(logn)<br>最坏情况：树高度等于节点数（即树退化为链表），所有操作的时间复杂度退化为 O(n)</p>
<h3 id="说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况"><a href="#说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况" class="headerlink" title="说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况"></a>说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况</h3><p>最小生成树算法主要有普里姆算法（Prim’s）和克鲁斯卡尔算法（Kruskal’s）：<br>普里姆算法：<br>时间复杂度：依赖于数据结构，使用优先队列时为 O(ElogV)。<br>过程：从任一顶点开始，逐渐增加边，总是选择连接已有树与未连接顶点中最小的边。<br>适用情况：适用于稠密图，因为它依赖于顶点数。</p>
<p>克鲁斯卡尔算法：<br>时间复杂度：O(ElogE) 或 O(ElogV)，主要由排序边的时间复杂度决定。<br>过程：按边的权重顺序处理所有边，选择不形成环的边，直至连接所有顶点。<br>适用情况：适用于稀疏图，因为算法从边的角度出发。</p>
<h3 id="关键路径和关键活动的概念"><a href="#关键路径和关键活动的概念" class="headerlink" title="关键路径和关键活动的概念"></a>关键路径和关键活动的概念</h3><p>在数据结构中，关键路径是指在有向图中从起点到终点的最长路径，这条路径上的活动被称为关键活动。关键路径代表了完成整个项目所需的最长时间，而关键活动是项目中时间安排上不可压缩的任务，即任何一个关键活动的延迟都将导致整个项目延期。</p>
<h3 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树（Balanced Binary Tree），也被称为AVL树（以发明者Adelson-Velsky和Landis的名字命名），是一种特殊类型的二叉搜索树。在这种树中，任何两个叶子节点之间的高度差都不会超过一定的限制，这个限制通常是1。这种高度平衡的特性确保了树的操作（如插入、删除和查找）可以在对数时间内完成，从而提高了数据结构的性能。平衡二叉树通过旋转调整的机制，有效避免了二叉搜索树在最坏情况下退化为链表的问题，从而在各种操作中都能提供良好的性能。</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树（Huffman Tree），也被称为最优二叉树，是一种特殊的二叉树结构，它在数据压缩、编码以及通信领域有广泛的应用。主要用于有效编码，以减少数据传输过程中的总位数或存储数据时所需的空间。</p>
<h4 id="哈夫曼树的特点："><a href="#哈夫曼树的特点：" class="headerlink" title="哈夫曼树的特点："></a>哈夫曼树的特点：</h4><ol>
<li><strong>最优二叉树</strong>：在所有可能的二叉树中，哈夫曼树的加权路径长度（WPL，即树中所有叶子节点的权值与其路径长度乘积之和）最小，因此也被称为最优二叉树。</li>
<li><strong>贪心算法构建</strong>：哈夫曼树的构建是通过贪心算法实现的。从底向上的构建过程中，每一步都选择两个权值最小的树合并，直到所有的树合并成一棵树。</li>
<li><strong>叶子节点存放数据</strong>：在哈夫曼树中，所有用于表示数据的节点都是叶子节点，且每个叶子节点都代表一个数据或字符，其权值通常是该数据在序列中出现的频率。</li>
<li><strong>无歧义编码</strong>：由哈夫曼树生成的编码是前缀码，即任何字符的编码都不是另一个字符编码的前缀，这消除了编码的歧义性，确保了编码的唯一解码性。</li>
<li><strong>动态调整</strong>：虽然哈夫曼树对一个给定的数据集是最优的，但如果数据集变化，原有的哈夫曼树可能不再是最优的。因此，在实际应用中，可能需要对哈夫曼树进行动态调整。</li>
</ol>
<p>哈夫曼树的应用非常广泛，特别是在数据压缩（如ZIP文件格式）和编码通信领域。通过减少无用信息的存储和传输，哈夫曼编码显著提高了数据处理的效率。</p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="Cache-是什么，为什么用-cache，原理-有几种映射方式"><a href="#Cache-是什么，为什么用-cache，原理-有几种映射方式" class="headerlink" title="Cache 是什么，为什么用 cache，原理,有几种映射方式"></a>Cache 是什么，为什么用 cache，原理,有几种映射方式</h3><p>Cache（缓存）是一种高速数据存储层，其目的是临时存储一部分数据，这些数据在短时间内可能会被再次访问。使用缓存可以减少访问原始数据源（如硬盘或远程服务器）的次数，从而显著提高数据访问的速度和系统整体的性能。</p>
<h3 id="为什么使用Cache"><a href="#为什么使用Cache" class="headerlink" title="为什么使用Cache?"></a>为什么使用Cache?</h3><p>减少延迟：访问缓存数据比访问主存储（如硬盘）快得多，这有助于减少程序执行的延迟时间。<br>降低后端负载：通过减少对后端服务器的直接请求，可以显著降低服务器的负载，提高系统的扩展性和稳定性。<br>提高性能：缓存经常访问的数据可以显著提高应用程序的响应速度和整体性能。</p>
<h3 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a>缓存的原理</h3><p>缓存工作的基本原理是数据的局部性原理，即在短时间内，程序访问的数据和指令往往局限于某个局部区域。这包括：</p>
<p>时间局部性：如果一个数据被访问，那么在不久的将来它可能被再次访问。<br>空间局部性：如果一个数据被访问，那么它附近的数据也很可能被访问。</p>
<h3 id="缓存的映射方式"><a href="#缓存的映射方式" class="headerlink" title="缓存的映射方式"></a>缓存的映射方式</h3><p>缓存中的数据是如何映射和存储的关键问题之一。有三种基本的映射方式：</p>
<p>直接映射（Direct Mapped Cache）</p>
<p>每个块只有一个固定的位置，通过地址的某些位直接决定。<br>实现简单，成本低，但可能出现高冲突率。<br>全相联映射（Fully Associative Cache）</p>
<p>任何块可以放在缓存中的任何位置。<br>查找灵活，不容易冲突，但成本高，查找时间长。<br>组相联映射（Set Associative Cache）</p>
<p>折中方案，缓存被分为几个组，每个块根据地址的某些位被映射到一个组，但在这个组内部可以放在任何位置。<br>结合了直接映射和全相联映射的优点，通过调整组的大小和数量可以平衡查找时间和冲突率。<br>通过这些映射方式，缓存可以有效地存储和检索数据，从而提高数据访问的速度和效率。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是FCB"><a href="#什么是FCB" class="headerlink" title="什么是FCB"></a>什么是FCB</h3><p>FCB是文件控制块，用来存放文件在磁盘中的相关信息，比如文件名、类型、文件所存储位置的指针等</p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ol>
<li><strong>基本概念</strong>:<ul>
<li><strong>进程（Process）</strong>：是操作系统进行资源分配和调度的一个独立单位，是应用程序的一次执行活动。每个进程都有自己独立的地址空间、内存、数据栈以及其他记录其运行轨迹的辅助数据。进程间通信需要通过进程间通信机制（IPC）来实现，如管道、信号、套接字、共享内存等。</li>
<li><strong>线程（Thread）</strong>：是进程中的一个实体，被系统独立调度和分派的基本单位。一个进程可以包含多个线程，它们共享进程的地址空间和资源，但每个线程有自己的执行栈和程序计数器。线程间的通信和数据共享更简单，因为它们共享相同的进程资源。</li>
</ul>
</li>
<li><strong>资源管理</strong>:<ul>
<li><strong>进程</strong>：拥有完全独立的资源，进程间资源不共享，切换代价大，资源消耗较多。</li>
<li><strong>线程</strong>：同一进程内的线程共享进程资源，如内存和文件描述符等，线程切换代价小，资源消耗较少。</li>
</ul>
</li>
<li><strong>执行流</strong>:<ul>
<li><strong>进程</strong>：每个进程都有独立的执行流，进程间互不干扰。</li>
<li><strong>线程</strong>：同一进程内的多个线程可并发执行，共享相同的执行环境。</li>
</ul>
</li>
<li><strong>通信方式</strong>:<ul>
<li><strong>进程</strong>：由于进程间资源独立，它们之间的通信需要使用操作系统提供的进程间通信机制。</li>
<li><strong>线程</strong>：由于共享进程资源，线程间通信更为方便，可以直接通过读写进程数据段中的数据来进行。</li>
</ul>
</li>
<li><strong>系统开销</strong>:<ul>
<li><strong>进程</strong>：创建和销毁进程的系统开销大，上下文切换时间长。</li>
<li><strong>线程</strong>：创建和销毁线程的系统开销小，上下文切换时间短，效率高。</li>
</ul>
</li>
</ol>
<h3 id="死锁的产生和避免"><a href="#死锁的产生和避免" class="headerlink" title="死锁的产生和避免?"></a>死锁的产生和避免?</h3><p>死锁的四个必要条件：<br>(1)互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。<br>(2)请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。<br>(3)非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。<br>(4)循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</p>
<p>　死锁避免（deadlock avoidence）是在系统运行过程中注意避免死锁的发生。这就要求每当申请一个资源时，系统都应根据一定的算法判断是否认可这次申请，使得在今后一段时间内系统不会出现死锁。这面方最著名的算法首推Dijkstra[1965]提出的银行家（banker）算法。</p>
<h3 id="串行总线和并行总线的区别"><a href="#串行总线和并行总线的区别" class="headerlink" title="串行总线和并行总线的区别"></a>串行总线和并行总线的区别</h3><p>串行总线和并行总线的主要区别在于数据传输方式。串行总线在单一通道上逐位顺序传输数据，占用的线路少，但传输速度受限于单个通道的速率，常见于USB、SATA等接口。并行总线同时在多个通道上传输数据，理论上可以提供更高的传输速度，但随着传输距离的增加，易受到信号干扰和时钟同步的挑战，典型应用包括早期的IDE接口和计算机内部的数据总线。随着技术进步，高速串行总线因其较高的信号完整性和扩展性而越来越受到青睐。</p>
<h3 id="谈谈冯·诺伊曼计算机体系结构"><a href="#谈谈冯·诺伊曼计算机体系结构" class="headerlink" title="谈谈冯·诺伊曼计算机体系结构"></a>谈谈冯·诺伊曼计算机体系结构</h3><p>冯·诺伊曼体系结构（Von Neumann architecture），也称为冯·诺伊曼模型，是现代计算机架构的基础。这种体系结构是由匈牙利数学家和物理学家约翰·冯·诺伊曼在1945年提出的。它的主要设计思想和特点包括：</p>
<ol>
<li><strong>存储程序控制</strong>：冯·诺伊曼体系结构的核心特点之一是将程序指令和数据一同存储在计算机的内存中。这意味着计算机可以按照存储的指令自动执行操作，而无需每次执行新任务时都进行硬件重组。</li>
<li><strong>处理单元</strong>：包含算术逻辑单元（ALU）和处理器寄存器，是执行所有计算和逻辑操作的地方。处理器通过执行存储在内存中的指令来处理数据。</li>
<li><strong>控制单元</strong>：从内存中获取指令，解码它们，然后按顺序或根据指令要求执行它们。控制单元控制着整个计算机的操作流程。</li>
<li><strong>内存单元</strong>：存储程序指令和程序处理的数据。冯·诺伊曼体系结构中没有区分程序和数据的存储，它们都存放在同一个内存系统中，可以用同样的方式访问。</li>
<li><strong>输入/输出机制</strong>：允许计算机与外部世界进行交互，包括读取输入数据和输出处理结果。</li>
<li><strong>顺序执行</strong>：在冯·诺伊曼体系结构中，指令通常被顺序执行，一个接一个地进行，除非遇到明确的跳转指令改变执行顺序。</li>
</ol>
<p>冯·诺伊曼体系结构的提出极大地促进了计算机科学的发展，为现代计算机设计提供了基础。然而，它也有一些局限性，比如“冯·诺伊曼瓶颈”，这是指计算机的处理能力受限于从内存到处理器的数据传输速率。随着计算机科学的发展，人们提出了各种方法来克服这些限制，例如引入缓存、采用并行处理架构等。</p>
<h3 id="为什么要引入中断"><a href="#为什么要引入中断" class="headerlink" title="为什么要引入中断"></a>为什么要引入中断</h3><p>早期计算机各个程序只能串行执行、系统资源利用低。为了解决上述问题，人们就发明了中断机制。有了中断，才能实现多道程序并发执行。</p>
<h3 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h3><p>云计算是分布式计算的一种，指的是通过网络”云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。</p>
<h3 id="页表和段表的区别有什么"><a href="#页表和段表的区别有什么" class="headerlink" title="页表和段表的区别有什么"></a>页表和段表的区别有什么</h3><p>①页表以页为单位，页的大小是固定的：段表以段为单位，段的大小可以不同。<br>②页表表示的是页号和页内偏移量：段表表示的是段号和段内偏移量。<br>③页表可能会产生页内碎片；段表可能会产生外部碎片。<br>④页表通常用于实现OS和用户程序间内存保护，确保用户不能访问OS系统空间：段表通常用于实<br>现各进程间的内存保护，不同的进程可以有不同的地址空间。</p>
<h3 id="描述下中断的过程"><a href="#描述下中断的过程" class="headerlink" title="描述下中断的过程"></a>描述下中断的过程</h3><p>首先，外部设备或执行的程序发出中断请求，如有多个请求同时发出，Cu会进行中断判优，选取<br>优先级最高的中断请求；然后，进行中断响应，首先要关中断，保存断点，然后获得中断服务程序<br>的入口地址；再进入中断服务程序，先保护现场，然后开中断，进行中断服务，然后再关中断，恢<br>复现场，开中断，中断返回。</p>
<h3 id="简述下如何将链表逆置"><a href="#简述下如何将链表逆置" class="headerlink" title="简述下如何将链表逆置"></a>简述下如何将链表逆置</h3><p>主要是运用链表的头插法，首先设置两个指针p和r，有个带头结点的单链表L,让p指向L的下一<br>项，然后L头结点跟指向的下一项断开，只要p不为空开始循环：r指向p的下一项，p的指针指向L<br>的下一项，L的指针指向P,p指向r。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="Q：五层协议的体系结构分别是什么？每一层都有哪些协议？"><a href="#Q：五层协议的体系结构分别是什么？每一层都有哪些协议？" class="headerlink" title="Q：五层协议的体系结构分别是什么？每一层都有哪些协议？"></a>Q：五层协议的体系结构分别是什么？每一层都有哪些协议？</h3><p><strong>应用层</strong>：应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，还要作为互相作用的应用进程的用户代理（user agent)；<br>HTTP（超文本传输协议）：用于网页数据的传输。<br>FTP（文件传输协议）：用于文件的传输。<br>SMTP（简单邮件传输协议）：用于发送电子邮件。<br>DNS（域名系统）：用于解析域名到IP地址。</p>
<p><strong>运输层</strong>：负责主机中两个进程间的通信；<br>TCP（传输控制协议）：提供面向连接的、可靠的数据传输服务。<br>UDP（用户数据报协议）：提供无连接的、尽最大努力交付的数据传输服务。</p>
<p><strong>网络层</strong>：负责为分组选择合适的路由；<br>IP（互联网协议）：是用于路由选择的核心协议。<br>ICMP（互联网控制消息协议）：用于传递控制消息。</p>
<p><strong>数据链路层</strong>：将在网络层交下来的数据报组装成帧（frame)，两个相邻结点间的链路实现帧的传输；<br>PPP（点对点协议）：用于直接连接两个网络节点。</p>
<p>ARP（地址解析协议）：用于将网络地址转换为物理地址。</p>
<p><strong>物理层</strong>：透明地传输比特流。物理层不涉及协议，而是定义了电气信号、线路标准和网络设备的物理规格 </p>
<h3 id="Q：为何有MAC地址还要IP地址？"><a href="#Q：为何有MAC地址还要IP地址？" class="headerlink" title="Q：为何有MAC地址还要IP地址？"></a>Q：为何有MAC地址还要IP地址？</h3><p>基本上一个观点就是一个是物理地址，一个是逻辑地址。</p>
<p>假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络。</p>
<p> 然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。</p>
<p>如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。</p>
<p>电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。</p>
<p>话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送。</p>
<h3 id="ip地址的组成"><a href="#ip地址的组成" class="headerlink" title="ip地址的组成"></a>ip地址的组成</h3><p>ip地址由子网掩码和主机号组成。</p>
<p>子网掩码确定主机所在的网络。这部分指定了主机所属的网络地址，用于区分IP地址空间中的不同网络。 </p>
<p>主机号确定网络中的具体主机。这部分指定了该网络中的具体设备，用于识别网络内的单个主机。</p>
<p>在IP地址中，当主机号（Host Identifier）部分全为0时，这表示的是一个<strong>网络地址</strong>。网络地址用于标识一个特定的网络而不是网络上的具体主机。</p>
<p>在IP地址中，当主机号（Host Identifier）部分全为1时，这表示的是一个<strong>广播地址</strong>。广播地址用于在网络中的所有主机之间发送数据。当数据包发送到广播地址时，网络上的每台主机都会接收到这个数据包。</p>
<h3 id="传输层功能："><a href="#传输层功能：" class="headerlink" title="传输层功能："></a>传输层功能：</h3><p>提供应用进程之间的逻辑通信，即端到端；分用和复用；差错检测首部和数据部分<br>（网络层只差错检查首部）；提供TCP和UDP协议。</p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>发送方不同的应用进程都可使用同一个传输层协议传送数据。</p>
<h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>防止过多的数据注入网络，让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>指点对点的通信量的控制，抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="Q：TCP和UDP的区别？"><a href="#Q：TCP和UDP的区别？" class="headerlink" title="Q：TCP和UDP的区别？"></a>Q：TCP和UDP的区别？</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<h3 id="Q：拥塞控制和流量控制都是什么，两者的区别？"><a href="#Q：拥塞控制和流量控制都是什么，两者的区别？" class="headerlink" title="Q：拥塞控制和流量控制都是什么，两者的区别？"></a>Q：拥塞控制和流量控制都是什么，两者的区别？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/53716367">https://blog.csdn.net/ailunlee/article/details/53716367</a></p>
<p>流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。<br>拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</p>
<h3 id="Q：谈谈TCP为什么要三次握手？为什么要四次挥手？"><a href="#Q：谈谈TCP为什么要三次握手？为什么要四次挥手？" class="headerlink" title="Q：谈谈TCP为什么要三次握手？为什么要四次挥手？"></a>Q：谈谈TCP为什么要三次握手？为什么要四次挥手？</h3><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>三次握手（SYN, SYN-ACK, ACK）的目的是可靠地建立两个TCP端点之间的连接。它确保双方都知道对方的接收和发送能力是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：客户端发送SYN包（同步序列编号）到服务器以开始新连接。</li>
<li><strong>第二次握手</strong>：服务器回应一个SYN-ACK包，确认收到客户端的SYN。</li>
<li><strong>第三次握手</strong>：客户端再次发送ACK包响应，确认收到服务器的SYN-ACK。</li>
</ol>
<p>这种机制确保了双方都能确认自己和对方的发送和接收是正常的，避免了初始化连接的不确定性和资源浪费。</p>
<h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>四次挥手（FIN, ACK, FIN, ACK）的目的是可靠地终止两个TCP端点之间的连接。因为TCP连接是全双工的，即数据可以在两个方向上流动，所以每个方向都必须单独进行关闭。</p>
<ol>
<li><strong>第一次挥手</strong>：当通信的一方完成数据发送任务后，发送一个FIN包，请求关闭连接。</li>
<li><strong>第二次挥手</strong>：另一方确认收到FIN包，回送一个ACK包。</li>
<li><strong>第三次挥手</strong>：另一方也发送一个FIN包，请求关闭另一方向的连接。</li>
<li><strong>第四次挥手</strong>：最初请求关闭连接的一方确认收到另一方的FIN包，回送一个ACK包。</li>
</ol>
<p>这种分步关闭机制确保了数据在连接关闭前能完整传输，且双方都清楚连接何时完全关闭，从而优雅地关闭连接，释放资源。</p>
<h3 id="Q：播放视频用TCP还是UDP？为什么？"><a href="#Q：播放视频用TCP还是UDP？为什么？" class="headerlink" title="Q：播放视频用TCP还是UDP？为什么？"></a>Q：播放视频用TCP还是UDP？为什么？</h3><p>播放视频时，既可以使用TCP也可以使用UDP，选择哪一个取决于应用场景的具体需求和优先级。</p>
<h4 id="使用TCP的情况："><a href="#使用TCP的情况：" class="headerlink" title="使用TCP的情况："></a>使用TCP的情况：</h4><ul>
<li><strong>需求强调数据的完整性和可靠性</strong>：如果视频播放的应用场景对数据传输的完整性和可靠性有很高的要求，比如点播服务、文件下载，或需要确保每一帧数据都不丢失且完整到达，那么应该使用TCP。</li>
<li><strong>自适应网络条件的能力</strong>：TCP有拥塞控制和流量控制机制，能根据网络状况自动调整数据传输速率，避免网络拥堵。</li>
</ul>
<h4 id="使用UDP的情况："><a href="#使用UDP的情况：" class="headerlink" title="使用UDP的情况："></a>使用UDP的情况：</h4><ul>
<li><strong>需求强调实时性和低延迟</strong>：如果视频播放更注重流畅度和低延迟，比如直播或实时视频会议，UDP更为合适。UDP不需要进行连接的建立和维护，也不会因为数据重传而增加额外的延迟。</li>
<li><strong>允许数据丢失</strong>：UDP不保证数据的可靠性，少量数据包的丢失可以通过应用层的一些策略来弥补，如错误恢复技术和冗余发送关键数据。</li>
</ul>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li><strong>对于点播系统</strong>，倾向于选择TCP，因为它需要数据的完整性和可靠性更高。</li>
<li><strong>对于直播系统</strong>，倾向于使用UDP，因为它对实时性的要求更高，而且可以容忍一定程度的数据丢失。</li>
</ul>
<h3 id="TCP怎么实现可靠传输"><a href="#TCP怎么实现可靠传输" class="headerlink" title="TCP怎么实现可靠传输"></a>TCP怎么实现可靠传输</h3><p> TCP（传输控制协议）通过一系列机制确保数据的可靠传输，这些机制包括：</p>
<ol>
<li><strong>序列号和确认应答（Sequence Numbers and Acknowledgments）</strong>：TCP为每个发送的数据包分配一个序列号，接收方在收到数据包后会发送一个确认应答（ACK），包含下一个期望接收的序列号。这确保了数据的按序到达和重复数据的检测。</li>
<li><strong>数据重传（Retransmission）</strong>：如果发送方在设定的超时时间内没有收到对方的确认应答，它会重传那个数据包。这处理了数据包丢失的问题。</li>
<li><strong>流量控制（Flow Control）</strong>：TCP使用窗口大小（Window Size）机制来控制发送方的数据传输速率，防止接收方的缓冲区被溢出。窗口大小基于接收方的处理能力动态调整。</li>
<li><strong>拥塞控制（Congestion Control）</strong>：TCP通过减少其发送数据的速率来响应网络拥堵的迹象，如数据包丢失。它通过几种算法（如慢启动、拥塞避免、快重传和快恢复）动态调整数据的传输速度。</li>
<li><strong>有序重组（Ordered Reassembly）</strong>：接收方根据序列号将接收到的分段正确排序，确保数据最终按发送顺序重组。</li>
<li><strong>错误检测（Error Detection）</strong>：TCP头部包含一个校验和（Checksum）字段，用于检测数据在传输过程中的任何变化（例如，由于网络噪声）。如果检测到错误，受影响的数据包将被丢弃并请求重传。</li>
</ol>
<p>通过这些机制，TCP能够提供一种可靠的数据传输服务，在数据丢失、顺序错误、重复数据或数据损坏的情况下恢复传输，确保数据完整性和顺序的正确。</p>
<h3 id="Q：HTTP报文格式？"><a href="#Q：HTTP报文格式？" class="headerlink" title="Q：HTTP报文格式？"></a>Q：HTTP报文格式？</h3><p>请求报文由三部分组成：请求行、请求头部（Header）、消息主体（可选部分，包含发送的数据。对于GET请求通常为空，POST请求中通常包含表单数据或要上传的内容）。</p>
<p>响应报文由三部分组成：状态行、响应头部（Header）、消息主体。</p>
<h3 id="Q：了解哪些响应状态码？"><a href="#Q：了解哪些响应状态码？" class="headerlink" title="Q：了解哪些响应状态码？"></a>Q：了解哪些响应状态码？</h3><p>http状态返回代码 1xx（临时响应）：表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>http状态返回代码 2xx （成功）：表示成功处理了请求的状态代码。</p>
<p>http状态返回代码 3xx （重定向）：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p>http状态返回代码 4xx（请求错误）：这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p>http状态返回代码 5xx（服务器错误）：这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<h3 id="Q：Http1-0、Http1-1、Http2-0的区别？"><a href="#Q：Http1-0、Http1-1、Http2-0的区别？" class="headerlink" title="Q：Http1.0、Http1.1、Http2.0的区别？"></a>Q：Http1.0、Http1.1、Http2.0的区别？</h3><p>HTTP/1.0、HTTP/1.1 和 HTTP/2.0 是HTTP协议的三个主要版本</p>
<p>HTTP/1.0无连接复用：每次请求/响应后都会关闭TCP连接，再次请求需要重新建立连接。</p>
<p>HTTP/1.1<strong>连接复用</strong>：默认情况下，TCP连接在多个请求之间保持打开状态，减少了建立连接的开销。</p>
<p>HTTP/2.0<strong>流和多路复用</strong>：在单一连接中同时发送多个请求和响应，请求和响应可以分成独立的帧，这些帧交错发送并在另一端重新组装。</p>
<p>简而言之，HTTP/1.1 相对于 HTTP/1.0 主要增加了连接复用和虚拟主机支持，而 HTTP/2.0 在此基础上进一步引入了二进制分帧、流和多路复用、头部压缩和服务器推送等高效的新特性，大大提高了Web性能和效率。</p>
<h3 id="Q：HTTP和TCP的区别"><a href="#Q：HTTP和TCP的区别" class="headerlink" title="Q：HTTP和TCP的区别?"></a>Q：HTTP和TCP的区别?</h3><p>  HTTP是应用层的协议，主要规定了客户端和服务器之间的通信格式和规则，用于传输超文本等数据。TCP是传输层的协议，提供可靠的、面向连接的通信服务，确保数据的正确传输。简而言之，HTTP依赖于TCP来实现在网络中的数据传输，TCP为HTTP提供支持，但二者工作在不同的网络模型层级，解决不同的通信问题。HTTP关注数据内容的结构和表示，而TCP关注于数据包的准确送达。</p>
<h3 id="Q：HTTP和HTTPS的区别"><a href="#Q：HTTP和HTTPS的区别" class="headerlink" title="Q：HTTP和HTTPS的区别?"></a>Q：HTTP和HTTPS的区别?</h3><p>HTTP和HTTPS的主要区别在于安全性。HTTPS是HTTP的安全版本，它在传输数据时通过SSL/TLS协议进行加密，保护数据免受中间人攻击，确保数据传输的安全性和完整性。HTTP传输数据不加密，容易被窃听或篡改。HTTPS默认使用443端口，而HTTP使用80端口。虽然HTTPS提高了安全性，但加密解密过程增加了计算开销，可能会稍微影响性能。</p>
<h3 id="Q：HTTP和Socket的区别"><a href="#Q：HTTP和Socket的区别" class="headerlink" title="Q：HTTP和Socket的区别?"></a>Q：HTTP和Socket的区别?</h3><p>Socket是网络编程中的一个接口（API），提供创建网络应用的方式，支持TCP/UDP协议，实现端到端的数据通信。Socket更为底层，可以用于构建各种协议，包括HTTP。</p>
<p>Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。</p>
<h3 id="Q：在地址栏打入http-www-baidu-com会发生什么？"><a href="#Q：在地址栏打入http-www-baidu-com会发生什么？" class="headerlink" title="Q：在地址栏打入http://www.baidu.com会发生什么？"></a>Q：在地址栏打入<a href="http://www.baidu.com会发生什么？">http://www.baidu.com会发生什么？</a></h3><ol>
<li><strong>域名解析</strong>：用户在浏览器地址栏输入网站域名，如<code>www.example.com</code>。浏览器首先查询本地DNS缓存，若未找到，向配置的DNS服务器发起解析请求，将域名解析为服务器的IP地址。</li>
<li><strong>建立连接</strong>：浏览器使用解析得到的IP地址，通过TCP协议发起对服务器的连接请求。若是HTTPS，还需建立加密通道。</li>
<li><strong>发送HTTP请求</strong>：一旦TCP连接建立，浏览器就构建一个HTTP请求消息发送给服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到HTTP请求后，根据请求的资源路径（URL），调用后端程序处理请求。处理过程可能涉及查询数据库、执行后端逻辑等操作。</li>
<li><strong>发送HTTP响应</strong>：服务器处理完请求后，会构建一个HTTP响应消息并发送回客户端。</li>
<li><strong>渲染页面</strong>：浏览器接收到HTTP响应后，根据响应体中的HTML内容开始解析和渲染页面。如果HTML中包含外部资源的链接（如CSS、JavaScript文件、图片等），浏览器会再次发起HTTP请求获取这些资源。</li>
<li><strong>关闭连接</strong>：页面及其相关资源全部加载完成后，若没有设置持久连接，浏览器和服务器会关闭TCP连接。</li>
</ol>
<p>整个过程涵盖了域名解析（应用层DNS协议）、建立连接（传输层TCP协议）、安全加密（TLS协议）、内容请求和传输（应用层HTTP/HTTPS协议）等多个网络层次的操作</p>
<h3 id="Q：长链接与短连接？"><a href="#Q：长链接与短连接？" class="headerlink" title="Q：长链接与短连接？"></a>Q：长链接与短连接？</h3><p>短链接就是无链接复用，每次请求/响应后都会关闭TCP连接，再次请求需要重新建立连接。</p>
<p>长连接是连接复用，默认情况下，TCP连接在多个请求之间保持打开状态，减少了建立连接的开销。</p>
<h3 id="路由器在计算机网络的哪一层？有什么功能？"><a href="#路由器在计算机网络的哪一层？有什么功能？" class="headerlink" title="路由器在计算机网络的哪一层？有什么功能？"></a>路由器在计算机网络的哪一层？有什么功能？</h3><p>路由器工作在计算机网络网络层。路由器的主要功能是：</p>
<ul>
<li>路由选择：确定数据包从源到目的地的最佳路径。</li>
<li>分组转发：根据路由选择的路径转发数据包到下一个网络段或目的地。</li>
<li>子网流量管理：控制网络流量，避免网络拥塞。</li>
<li>网络互连：连接不同的网络技术，如以太网和Wi-Fi。</li>
<li>数据包过滤和安全控制：可能包括防火墙功能，对通过的数据包进行过滤。</li>
</ul>
<h3 id="应用层协议："><a href="#应用层协议：" class="headerlink" title="应用层协议："></a>应用层协议：</h3><p>1、远程登录协议(Telnet)<br>2、文件传输协议（FTP）<br>3、超文本传输协议（HTTP）<br>4、域名服务协议（DNS）<br>5、简单邮件传输协议（SMTP）<br>6、邮局协议（POP3）</p>
<p>其中，从网络上下载文件时使用的是FTP协议，上网游览网页时使用的是HTTP协议；在网络上访问一台主机时，通常不直接输入IP地址，而是输入域名，用的是DNS服务协议，它会将域名解析为IP地址；通过FoxMail发送电子邮件时，使用SMTP协议，接收电子邮件时就使用POP3协议。</p>
<h3 id="传输层协议："><a href="#传输层协议：" class="headerlink" title="传输层协议："></a>传输层协议：</h3><p>1、传输控制协议TCP<br>2、用户数据报协议UDP</p>
<p>TCP协议：面向连接的可靠传输协议。利用TCP进行通信时，首先要通过三步握手，以建立通信双方的连接。TCP提供了数据的确认和数据重传的机制，保证发送的数据一定能到达通信的对方。</p>
<p>UDP协议：是无连接的，不可靠的传输协议。采用UDP进行通信时不用建立连接，可以直接向一个IP地址发送数据，但是不能保证对方是否能收到。</p>
<h3 id="网络层协议："><a href="#网络层协议：" class="headerlink" title="网络层协议："></a>网络层协议：</h3><p>网际协议 (IP)：这是用于发送数据包从一个主机传送到另一个主机的协议，主要用于路由选择。它仅负责传送，不保证数据包的顺序和完整性。</p>
<p>互联网控制报文协议 (ICMP)：该协议用于IP主机、路由器之间传递控制消息，例如目的不可达、时间超出等，用于错误报告和状态查询。</p>
<p>互联网组织管理协议 (IGMP)：用于在IP主机和相邻的路由器之间管理多播组成员资格的协议。</p>
<p>地址解析协议 (ARP)：用于在本地网络内部解析网络层的地址到链路层地址，例如将IP地址转换为以太网的MAC地址。</p>
<h3 id="简单介绍下频分复用、时分复用、波分复用、码分复用"><a href="#简单介绍下频分复用、时分复用、波分复用、码分复用" class="headerlink" title="简单介绍下频分复用、时分复用、波分复用、码分复用"></a>简单介绍下频分复用、时分复用、波分复用、码分复用</h3><p>频分复用：将信道分成不同的频率段，不同的信号在不同的频段中传输。</p>
<p>时分复用：将一个信道的使用时间分成一个个时间片，不同的主机在不同的时间片内使用信道。</p>
<p> 波分复用：主要用于光介质传输，通过光的衍射技术，将波长划分为一定的波长范围，每个用户占 用一个波长范围来传输。</p>
<p>码分复用：给每个用户分配不同的码型来表示0和1，不同用户之间的码型需要正交才能传输。</p>
<h3 id="为什么要进行流量控制"><a href="#为什么要进行流量控制" class="headerlink" title="为什么要进行流量控制"></a>为什么要进行流量控制</h3><p>因为收发信息双方处理信息的速度不一致，太快会导致接收方来不及接受而丢失信息，太慢会使信道利用率降低。</p>
<h3 id="什么是DHCP"><a href="#什么是DHCP" class="headerlink" title="什么是DHCP"></a>什么是DHCP</h3><p>动态主机配置协议，运行在局域网内，使用UDP协议为本网络内的主机分配IP地址。 </p>
<h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3><p>域名服务器，实现域名地址和IP地址之间的映射，方便用户对网址的访问。用户机通过DNS服务器 发出的询问报文来获得对应域名的ip地址。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Q：数据库中的事务了解吗？事务的四大特性？"><a href="#Q：数据库中的事务了解吗？事务的四大特性？" class="headerlink" title="Q：数据库中的事务了解吗？事务的四大特性？"></a>Q：数据库中的事务了解吗？事务的四大特性？</h3><p>数据库事务是数据库运行中的逻辑工作单位，单个逻辑工作单元所执行的一系列操作，要么都执行，要么都不执行。例如银行取款事务分为2个步骤(1)存折减款(2)提取现金，2个步骤必须同时完成或者都不完成。</p>
<p>数据库事务的四大特性（ACID)：</p>
<p>(1) 原子性(Atomicity)：<br>     事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br>(2)一致性(Consistency) ：<br>    事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。<br>(3)分离性(Isolation)：<br>   分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。<br>(4)持久性(Durability)：<br>   持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</p>
<h3 id="Q：如何理解数据库的范式？"><a href="#Q：如何理解数据库的范式？" class="headerlink" title="Q：如何理解数据库的范式？"></a>Q：如何理解数据库的范式？</h3><p>第一范式（1NF）：确保每一列的原子性</p>
<p>如果每一列都是不可再分的最小数据单元，则满足第一范式。</p>
<p>第二范式:非键字段必须依赖于键字段</p>
<p>如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。</p>
<p>第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性</p>
<p>（在2NF基础上消除传递依赖）</p>
<h3 id="混合索引的优点"><a href="#混合索引的优点" class="headerlink" title="混合索引的优点"></a>混合索引的优点</h3><p>混合索引（Composite Index），也常被称为复合索引，是数据库管理系统中一种将两个或更多列组合在一起创建的索引。这种索引可以极大地提高数据库查询的效率，特别是对于那些需要通过多个列来进行过滤的查询。混合索引的优点包括：</p>
<p>提高查询性能：通过将多个列组合成一个索引，数据库能够更快地定位到满足所有条件的数据行。这是因为复合索引减少了搜索空间，从而加速了查询速度。</p>
<p>减少排序和临时表的使用：在多列的查询操作中，如果这些列被包含在一个混合索引中，数据库可以利用索引的顺序来避免额外的排序操作，从而提高查询效率。</p>
<p>支持索引覆盖查询：当一个查询只需要访问索引中的列时，它可以直接使用索引来获取数据，而无需回表查询原始数据行。如果一个混合索引包含了查询所需的所有列，这可以显著减少磁盘I/O操作，进一步提高查询性能。</p>
<p>优化多条件查询：混合索引特别适合处理多条件查询，尤其是当这些条件涉及到多个列时。数据库可以利用混合索引来同时满足所有的查找条件，而不是分别对每个条件进行查找。</p>
<p>节省空间：相比于为每个列单独创建索引，一个混合索引可以节省存储空间，因为它合并了多个列的索引信息。虽然混合索引本身可能会比单列索引更大，但是总体上来说，避免了多个单列索引的冗余。</p>
<p>提高数据整合性和维护性：在某些情况下，混合索引可以用于维护数据的完整性。例如，在某些业务场景中，可以通过创建一个包含多个列的唯一索引来防止数据重复。</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>尊敬的各位老师，下午好！我非常荣幸能够参加今天的面试，并见到在座的各位专家。我是xx，今年xx岁，来自xxx。本科毕业于xx大学的xx专业。今天，我希望通过学习经历、实践经验和未来的读研规划这三个方面来介绍我自己。</p>
<p>在学习经历方面，我始终保持着积极进取的学习态度，对计算机科学领域充满热情。本科期间，我系统学习了数据结构、操作系统、计算机网络等计算机核心课程，这为我奠定了扎实的专业基础。此外我还坚持学习英语，并在本科期间顺利通过了英语四级。</p>
<p>关于实践经验，我积极参与校内外的多项活动，特别是加入了学校环保社团并作为志愿者积极参与流浪动物领养日活动，这不仅增强了我的责任感和同情心，也锻炼了我的组织和沟通能力。在科研方面，我选择了我深感兴趣的爬虫技术作为毕业论文的主题，通过全面的文献调研和实践操作，我基于 Xpath 自动提取算法 TSBased-AEXPath自动提取网页的xpath，利用scrapy框架爬取数据，数据经过pandas库处理后存储到redis数据库。使用gerapy管理分布式爬虫系统。最后我顺利完成了论文的答辩。这一过程不仅使我提升了研究和解决问题的能力，也使我产生了进一步学习的想法。所以我希望能够在研究生期间继续学习研究这方面。本科期间，我遇到了很多优秀的老师和同学，从他们那里我学到了很多东西，我也感受到我的专业知识水平还有待提高，因此我选择读研进一步深造，完善我的专业知识。和更优秀的人一起奋斗，不断提升自我。</p>
<p>展望未来，我希望能够通过面试，获得前来贵校深入学习研究的机会，继续在自己感兴趣的领域深造。我计划在深入学习专业知识的同时，培养研究能力和创新思维。我将努力参与学术论文的撰写和发表，通过不断阅读和研究，提高我的科研水平。同时，我也希望能参与导师的研究项目，通过团队合作和学术交流，拓宽我的视野，并全面提升我的学术及实践能力。</p>
<p>以上是我的自我介绍，感谢各位老师。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="机器学习中的欠拟合、过拟合是什么意思"><a href="#机器学习中的欠拟合、过拟合是什么意思" class="headerlink" title="机器学习中的欠拟合、过拟合是什么意思"></a>机器学习中的欠拟合、过拟合是什么意思</h3><p>欠拟合就是模型对训练数据的拟合程度不够，无法很好捕捉到数据中的规律和特征，无法对新数据 作出准确地预测，没有选好特征值。</p>
<p>过拟合是指模型对训练数据的表现很好，但在新数据上表现不佳，训练样本较少，特征值过多。</p>
<h3 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h3><p>深度学习是机器学习的一个新领域，主要是深度学习样本数据的内在规律和特征，能更好的识别文字、图像、声音等，让机器能够像人一样具有分析学习能力，是一种非常复杂的机器学习算法。</p>
<h3 id="什么是同步？什么是互斥？"><a href="#什么是同步？什么是互斥？" class="headerlink" title="什么是同步？什么是互斥？"></a>什么是同步？什么是互斥？</h3><p>同步是指不同的进程之间，必须按照一定的顺序来执行，比如吃水果问题，必须爸爸先往盘子里放水果，儿子女儿才能吃。互斥是指不同进程的一个程序片不能同时运行，比如多个程序都要访问某一个临界资源。</p>
<h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><p>具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。</p>
<h3 id="C语言中的void-是什么意思？有什么用处？"><a href="#C语言中的void-是什么意思？有什么用处？" class="headerlink" title="C语言中的void*是什么意思？有什么用处？"></a>C语言中的void*是什么意思？有什么用处？</h3><p>void是一种通用的指针类型，它可以指向任何数据类型的内存地址，因为它没有指定具体的数据类型。在C语言中，void＊可以表示任何类型的指针，如int、float、char＊等等。使用void＊可以实现函数的通用性，从而提高代码的灵活性和复用性。</p>
<h3 id="C语言中的头文件是什么？有什么用？"><a href="#C语言中的头文件是什么？有什么用？" class="headerlink" title="C语言中的头文件是什么？有什么用？"></a>C语言中的头文件是什么？有什么用？</h3><p>头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明。在include的地方，把头文件里的内容原封不动的复制到引用该头文件的地方。</p>
<h3 id="高级语言和低级语言有什么区别？"><a href="#高级语言和低级语言有什么区别？" class="headerlink" title="高级语言和低级语言有什么区别？"></a>高级语言和低级语言有什么区别？</h3><p>高级语言和低级语言的主要区别在于抽象层次的不同。高级语言更加接近自然语言，提供了更多的抽象层次，使得程序员更加方便地编写程序。低级语言更加接近计算机硬件，提供了更少的抽象层次，使得程序员需要更加精细地控制计算机硬件的细节。</p>
<h3 id="大内核和微内核有什么区别？"><a href="#大内核和微内核有什么区别？" class="headerlink" title="大内核和微内核有什么区别？"></a>大内核和微内核有什么区别？</h3><p>大内核是指将操作系统的主要功能模块都作为系统内核，运行在核心态。微内核是指只把最基本的功能保留在内核。大内核的优点是高性能，缺点是内核代码庞大，结构混乱，难以维护。微内核的优点是内核功能少，结构清晰，方便维护，缺点是需要频繁地在核心态和用户态之间切换，性能低。</p>
<h3 id="const与＃define区别？"><a href="#const与＃define区别？" class="headerlink" title="const与＃define区别？"></a>const与＃define区别？</h3><p>const是在编译阶段进行替换的，会对类型进行语法检查，＃define是在预处理阶段进行的，在预处理阶段是不会进行语法检查的。</p>
<h3 id="什么是局域网？"><a href="#什么是局域网？" class="headerlink" title="什么是局域网？"></a>什么是局域网？</h3><p>局域网是一种小型的网络系统，一般范围只有10米到10KM之间，传输速率快，时延短。</p>
<h3 id="请简要描述广度优先搜索的过程。"><a href="#请简要描述广度优先搜索的过程。" class="headerlink" title="请简要描述广度优先搜索的过程。"></a>请简要描述广度优先搜索的过程。</h3><p>首先遍历根节点，是用队列来实现的，然后遍历根节点的所有子节点，遍历完以后再遍历第一个被遍历的子节点的所有子节点。</p>
<h3 id="什么时候使用线程："><a href="#什么时候使用线程：" class="headerlink" title="什么时候使用线程："></a>什么时候使用线程：</h3><p>①需要频繁创建销毁时，因为线程开销较小。</p>
<p>②大量计算、频繁切换、耗时操作时，因为线程切换速度快。</p>
<p>③并行操作时。</p>
<h3 id="信号量如何克服忙等："><a href="#信号量如何克服忙等：" class="headerlink" title="信号量如何克服忙等："></a>信号量如何克服忙等：</h3><p>进程无法进入互斥区会一直忙等，通过信号量将处理机释放给其他进程。因此记录型信号量机制满足让权等待。</p>
<h3 id="死锁如何解除："><a href="#死锁如何解除：" class="headerlink" title="死锁如何解除："></a>死锁如何解除：</h3><p>①撤销死锁的全部进程。②逐个撤销死锁中的进程直至解除。③死锁中进程逐个强迫放弃所占资源直至解除。④从其他进程剥夺资源给死锁进程。</p>
<h3 id="死锁产生条件："><a href="#死锁产生条件：" class="headerlink" title="死锁产生条件："></a>死锁产生条件：</h3><p>①互斥：资源为临界资源。②请求和保持：至少有一个资源又申请别的。③不剥夺：已有资源还没用不能被剥夺。④循环等待。</p>
<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>是系统硬件和软件资源的管理者，为用户和软件提供接口，实现了对计算机资源的抽象，是最接近硬件的系统软件。</p>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><p>管道pipe、消息队列、共享存储、信号量、套接字等。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>进程中访问公共资源的一段代码。</p>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>一次只允许一个进程使用的共享资源</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>首先进程在创建的时候处于创建态；获得所有所需资源除cpu后进入就绪态；获得cpu进入运行态，若时间片到还没执行完就回到就绪态，若运行中出现等待事件则进入阻塞态，直到等待事件发生回到就绪态；当进程执行完成转到终止态。</p>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>先来先服务、短作业优先、优先级调度、高响应比优先、多级反馈队列调度算法、时间片轮法。</p>
<h3 id="向量中断"><a href="#向量中断" class="headerlink" title="向量中断"></a>向量中断</h3><p>指一种识别中断源的方式，目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。</p>
<h3 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h3><p>每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表。</p>
<h3 id="向量地址"><a href="#向量地址" class="headerlink" title="向量地址"></a>向量地址</h3><p>中断向量表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个进程长期得不到运行，长期处于等待状态，而优先级更高的进程处于运行状态。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>同一个进程集合内的进程相互等待而没有进程进入运行状态。</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>当有进程对系统提出请求时，系统先先检测当前进程资源请求是否大于此进程最大需求，若大于则不执行；若不大于，再检测当前的资源要求是否大于系统当前可分配数，若大于则不子分配，若不大于将进程要求的资源分配给它，通过安全性算法检测将资源分配给进程后系统是否处于安全状态，若处于安全状态则分配资源，若不处于则不予分配。</p>
<h3 id="程序链接方式"><a href="#程序链接方式" class="headerlink" title="程序链接方式"></a>程序链接方式</h3><p>静态链接、装入时动态连接、运行时动态链接。</p>
<h3 id="程序的装入方式"><a href="#程序的装入方式" class="headerlink" title="程序的装入方式"></a>程序的装入方式</h3><p>绝对装入、可重定位装入、动态运行时装入。</p>
<h3 id="用户程序变为可执行程序"><a href="#用户程序变为可执行程序" class="headerlink" title="用户程序变为可执行程序"></a>用户程序变为可执行程序</h3><p>①将代码编译为若干目标模块；②将目标模块和库函数进行链接成完整的装入代码；③将模块装入内存。</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>将一个程序分为一个个程序段，这些程序段不同时执行，且共享一个主存区，没有执行的时候放在外存，需要执行的时候调入内存，主要在同一个进程内部使用覆盖技术，以达到在小空间运行大程序的效果。</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>将暂时不用的进程从主存中移到外存，即中级调度，主要在不同进程之间进行，以达到在小空间运行多个程序的效果。</p>
<h3 id="内存连续分配管理方式"><a href="#内存连续分配管理方式" class="headerlink" title="内存连续分配管理方式"></a>内存连续分配管理方式</h3><p>单一连续分配、固定分区分配、动态分区分配。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>最佳置换OPT、先进先出FIFO、最近最久未使用LRU、时钟CLOCK、改进CLOCL（使用访问位和修改位）。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>存放逻辑页面和物理块的对应关系，实现页号到物理块号的地址映射。</p>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>特殊的cache，包含页表的全部或部分，加快地址映射的速度。</p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>先来先服务、最短寻道时间有限、SCAN算法、C—SCAN算法。</p>
<h3 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h3><p>总时延＝排队时延＋处理时延＋传输时延＋传播时延</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个比特即将到达终点时，发送端已经发送了多少个比特，即时延带宽积＝传播时延＊信道带宽。</p>
<h3 id="端到端通信"><a href="#端到端通信" class="headerlink" title="端到端通信"></a>端到端通信</h3><p>传输层为网络中的主机提供端到端的通信，完成进程之间的通信，端是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h3 id="点到点通信"><a href="#点到点通信" class="headerlink" title="点到点通信"></a>点到点通信</h3><p>物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，直接相连的结点之间的通信称为点到点通信，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时不能保证传输可靠性。</p>
<h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>有数据要发送就发送，会产生冲突，等待一段随机长的时间后重发该帧。</p>
<h3 id="CSMA协议（载波侦听多路访问）"><a href="#CSMA协议（载波侦听多路访问）" class="headerlink" title="CSMA协议（载波侦听多路访问）"></a>CSMA协议（载波侦听多路访问）</h3><p>①非持续：先侦听，如果介质空闲，开始发送如果介质忙，则等待一个随机分布的时间。（等待一个随机时间可以减少再次碰撞冲突的可能性；但在这个随机时间内介质上没有数据传送，则会发生浪费）<br>②1—持续：先侦听，如果介质空闲，开始发送，如果介质忙，持续侦听，一旦空闲立即发送，如果发生冲突，等待一个随机分布的时间。（持续式的延迟时间要少于非持续式；如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突）<br>③p—持续：先侦听，如果介质空闲，那么以p的概率发送，以（1—p）的概率延迟一个时间单元，发送如介质忙，持续侦听。</p>
<h3 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h3><p>①距离—向量路由算法（例如RIP算法）：所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。<br>②链路状态路由算法（例如OSPF算法）：每个结点通过广播的方式与所有其他结点交谈，但它仅告诉与它直接相连的链路的费用。</p>
<h3 id="ICMP网际控制报文协议"><a href="#ICMP网际控制报文协议" class="headerlink" title="ICMP网际控制报文协议"></a>ICMP网际控制报文协议</h3><p>用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，能提高IP数据报交付成功的机会，分为终点不可达、源点抑制、超时、参数问题、路由重定</p>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>通过计算机程序或机器来模拟、实现人类智能的技术和方法。</p>
<h3 id="强人工智能"><a href="#强人工智能" class="headerlink" title="强人工智能"></a>强人工智能</h3><p>具备人类同等智慧或超越，表现正常人类所具有的所有智能行为。弱人工智能：面向特定问题和工作（如AlphaGo）。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>是一种方法，或者说是一种算法，能够赋予机器进行学习的能力，使机器完成一些无法通过编程直接实现的功能。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>是机器学习领域一个新研究方向，深度学习样本数据的内在规律和表现层次，最终使机器能像人一样具有分析学习能力。</p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>事先准备好要输入的数据即训练样本和真实的输出结果即参考答案，计算机通过学习得出一个预测模型，再用已知的模型去预测未知的样本。（回归问题和分类问题）</p>
<p>非监督学习：仅通过样本特征和相关性来训练出相应预测模型。（聚类问题）</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>①仿造人脑神经元的结构和工作原理而构建，是一个由节点连接而成的大网，神经元抽象为节点（用于存储数字），神经突触被抽象为有权重的连接（决定数字的改变及传递）。</p>
<p>②分为输入层（将图像转换为网络可以理解的内容）、隐含层（有多层，识别出图像的一部分特征并计算）、输出层（给答案）。</p>
<p>③输入内容为图即图神经网络GNN；网络中神经元换成打包的神经元即胶囊网络；使用卷积对图像等处理即卷积神经网络CNN。</p>
<h3 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h3><p>输入内容为图（由点和边组成的图），结点包含属性，边描述了实体之间的关系（即知识图谱）。</p>
<h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>一个非常庞大且复杂的数据集，无法在一定时间范围内处理完。</p>
<h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><p>在大量数据中通过算法找到先前未发现的、具有价值的数据的过程。</p>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>是一种分布式共享数据库，每个数据块中包含了一批次的交易信息，通过去中心化的共识算法进行验证和确认。区块链中的数据一旦被写入，就不能篡改和删除，具有安全性和可靠性。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/17/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%82%92/" rel="prev" title="算法小炒">
      <i class="fa fa-chevron-left"></i> 算法小炒
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/29/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95/" rel="next" title="英文面试">
      英文面试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">前后端交互的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">get和post的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%81%E5%AE%A2%E5%95%86%E5%9F%8E%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.3.</span> <span class="nav-text">极客商城是一个什么样的项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xpath"><span class="nav-number">1.4.</span> <span class="nav-text">xpath</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue2%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E4%BC%A0%E7%BB%9Fjs%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">vue2的特点，相对于传统js有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8ATSBased-AEXPath%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">解释TSBased-AEXPath算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredis%EF%BC%8C%E5%AF%B9%E6%AF%94mysql%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.</span> <span class="nav-text">介绍一下redis，对比mysql的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">什么是线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b%E6%A0%91%E5%92%8Cb-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">b树和b+树的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">怎么理解数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E5%B9%B6%E6%AF%94%E8%BE%83%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.6.</span> <span class="nav-text">迭代和递归的特点，并比较优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">2.6.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">2.6.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">查找算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">2.8.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">2.9.</span> <span class="nav-text">快速排序的基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BD%AF%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">2.10.</span> <span class="nav-text">程序和软件有何不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">数组与链表有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%A6%E4%B8%BA2%E7%9A%84%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.12.</span> <span class="nav-text">度为2的树与二叉树有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.13.</span> <span class="nav-text">最小生成树有哪几种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAnlogn%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.14.</span> <span class="nav-text">时间复杂度为nlogn的排序算法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%AF%8F%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.15.</span> <span class="nav-text">图的存储方式有哪些？每一种方式优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-number">2.16.</span> <span class="nav-text">图的遍历和树的遍历有哪些区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%8C%E6%9C%80%E5%9D%8F%E5%92%8C%E6%9C%80%E5%A5%BD%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">2.17.</span> <span class="nav-text">二叉排序树是如何排序的，最坏和最好的时间复杂度是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E9%80%82%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.18.</span> <span class="nav-text">说一下最小生成树的算法，他们的时间复杂度，实现的过程，适用的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%92%8C%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.19.</span> <span class="nav-text">关键路径和关键活动的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">2.20.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">2.21.</span> <span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">2.21.1.</span> <span class="nav-text">哈夫曼树的特点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-cache%EF%BC%8C%E5%8E%9F%E7%90%86-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">Cache 是什么，为什么用 cache，原理,有几种映射方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Cache"><span class="nav-number">3.2.</span> <span class="nav-text">为什么使用Cache?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">缓存的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">缓存的映射方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFCB"><span class="nav-number">4.1.</span> <span class="nav-text">什么是FCB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E9%81%BF%E5%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">死锁的产生和避免?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E6%80%BB%E7%BA%BF%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text">串行总线和并行总线的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.</span> <span class="nav-text">谈谈冯·诺伊曼计算机体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E4%B8%AD%E6%96%AD"><span class="nav-number">4.6.</span> <span class="nav-text">为什么要引入中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="nav-number">4.7.</span> <span class="nav-text">什么是云计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E5%92%8C%E6%AE%B5%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">4.8.</span> <span class="nav-text">页表和段表的区别有什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.9.</span> <span class="nav-text">描述下中断的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B%E5%A6%82%E4%BD%95%E5%B0%86%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE"><span class="nav-number">4.10.</span> <span class="nav-text">简述下如何将链表逆置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">5.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E4%B8%80%E5%B1%82%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">Q：五层协议的体系结构分别是什么？每一层都有哪些协议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E4%B8%BA%E4%BD%95%E6%9C%89MAC%E5%9C%B0%E5%9D%80%E8%BF%98%E8%A6%81IP%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">Q：为何有MAC地址还要IP地址？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">5.3.</span> <span class="nav-text">ip地址的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">5.4.</span> <span class="nav-text">传输层功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8"><span class="nav-number">5.5.</span> <span class="nav-text">复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%94%A8"><span class="nav-number">5.6.</span> <span class="nav-text">分用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.7.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.8.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">5.9.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9ATCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.10.</span> <span class="nav-text">Q：TCP和UDP的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.11.</span> <span class="nav-text">Q：拥塞控制和流量控制都是什么，两者的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E8%B0%88%E8%B0%88TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">5.12.</span> <span class="nav-text">Q：谈谈TCP为什么要三次握手？为什么要四次挥手？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">5.12.1.</span> <span class="nav-text">为什么要三次握手？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">5.12.2.</span> <span class="nav-text">为什么要四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E7%94%A8TCP%E8%BF%98%E6%98%AFUDP%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.13.</span> <span class="nav-text">Q：播放视频用TCP还是UDP？为什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8TCP%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">5.13.1.</span> <span class="nav-text">使用TCP的情况：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UDP%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">5.13.2.</span> <span class="nav-text">使用UDP的情况：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="nav-number">5.13.3.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">5.14.</span> <span class="nav-text">TCP怎么实现可靠传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9AHTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="nav-number">5.15.</span> <span class="nav-text">Q：HTTP报文格式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="nav-number">5.16.</span> <span class="nav-text">Q：了解哪些响应状态码？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9AHttp1-0%E3%80%81Http1-1%E3%80%81Http2-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.17.</span> <span class="nav-text">Q：Http1.0、Http1.1、Http2.0的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9AHTTP%E5%92%8CTCP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.18.</span> <span class="nav-text">Q：HTTP和TCP的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9AHTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.19.</span> <span class="nav-text">Q：HTTP和HTTPS的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9AHTTP%E5%92%8CSocket%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.20.</span> <span class="nav-text">Q：HTTP和Socket的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E6%89%93%E5%85%A5http-www-baidu-com%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.21.</span> <span class="nav-text">Q：在地址栏打入http:&#x2F;&#x2F;www.baidu.com会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E9%95%BF%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-number">5.22.</span> <span class="nav-text">Q：长链接与短连接？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">5.23.</span> <span class="nav-text">路由器在计算机网络的哪一层？有什么功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">5.24.</span> <span class="nav-text">应用层协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">5.25.</span> <span class="nav-text">传输层协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">5.26.</span> <span class="nav-text">网络层协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8%E3%80%81%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E3%80%81%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8%E3%80%81%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8"><span class="nav-number">5.27.</span> <span class="nav-text">简单介绍下频分复用、时分复用、波分复用、码分复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.28.</span> <span class="nav-text">为什么要进行流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDHCP"><span class="nav-number">5.29.</span> <span class="nav-text">什么是DHCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDNS"><span class="nav-number">5.30.</span> <span class="nav-text">什么是DNS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">Q：数据库中的事务了解吗？事务的四大特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">Q：如何理解数据库的范式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">6.3.</span> <span class="nav-text">混合索引的优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.</span> <span class="nav-text">自我介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AC%A0%E6%8B%9F%E5%90%88%E3%80%81%E8%BF%87%E6%8B%9F%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">8.1.</span> <span class="nav-text">机器学习中的欠拟合、过拟合是什么意思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">8.2.</span> <span class="nav-text">什么是深度学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%92%E6%96%A5%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">什么是同步？什么是互斥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="nav-number">8.4.</span> <span class="nav-text">什么是类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84void-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%84%EF%BC%9F"><span class="nav-number">8.5.</span> <span class="nav-text">C语言中的void*是什么意思？有什么用处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">8.6.</span> <span class="nav-text">C语言中的头文件是什么？有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">高级语言和低级语言有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.8.</span> <span class="nav-text">大内核和微内核有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%B8%8E%EF%BC%83define%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.9.</span> <span class="nav-text">const与＃define区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%9F"><span class="nav-number">8.10.</span> <span class="nav-text">什么是局域网？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-number">8.11.</span> <span class="nav-text">请简要描述广度优先搜索的过程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="nav-number">8.12.</span> <span class="nav-text">什么时候使用线程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E5%BF%99%E7%AD%89%EF%BC%9A"><span class="nav-number">8.13.</span> <span class="nav-text">信号量如何克服忙等：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%EF%BC%9A"><span class="nav-number">8.14.</span> <span class="nav-text">死锁如何解除：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="nav-number">8.15.</span> <span class="nav-text">死锁产生条件：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS"><span class="nav-number">8.16.</span> <span class="nav-text">OS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">8.17.</span> <span class="nav-text">进程间通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">8.18.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-number">8.19.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">8.20.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.21.</span> <span class="nav-text">进程调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD"><span class="nav-number">8.22.</span> <span class="nav-text">向量中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F"><span class="nav-number">8.23.</span> <span class="nav-text">中断向量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80"><span class="nav-number">8.24.</span> <span class="nav-text">向量地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF"><span class="nav-number">8.25.</span> <span class="nav-text">饥饿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">8.26.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">8.27.</span> <span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">8.28.</span> <span class="nav-text">程序链接方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">8.29.</span> <span class="nav-text">程序的装入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">8.30.</span> <span class="nav-text">用户程序变为可执行程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96"><span class="nav-number">8.31.</span> <span class="nav-text">覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2"><span class="nav-number">8.32.</span> <span class="nav-text">交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">8.33.</span> <span class="nav-text">内存连续分配管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">8.34.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">8.35.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8"><span class="nav-number">8.36.</span> <span class="nav-text">快表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.37.</span> <span class="nav-text">磁盘调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E6%97%B6%E5%BB%B6"><span class="nav-number">8.38.</span> <span class="nav-text">总时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF"><span class="nav-number">8.39.</span> <span class="nav-text">时延带宽积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E9%80%9A%E4%BF%A1"><span class="nav-number">8.40.</span> <span class="nav-text">端到端通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%88%B0%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="nav-number">8.41.</span> <span class="nav-text">点到点通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ALOHA%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.42.</span> <span class="nav-text">ALOHA协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSMA%E5%8D%8F%E8%AE%AE%EF%BC%88%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="nav-number">8.43.</span> <span class="nav-text">CSMA协议（载波侦听多路访问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="nav-number">8.44.</span> <span class="nav-text">动态路由算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ICMP%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.45.</span> <span class="nav-text">ICMP网际控制报文协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span class="nav-number">8.46.</span> <span class="nav-text">人工智能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span class="nav-number">8.47.</span> <span class="nav-text">强人工智能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">8.48.</span> <span class="nav-text">机器学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">8.49.</span> <span class="nav-text">深度学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="nav-number">8.50.</span> <span class="nav-text">监督学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">8.51.</span> <span class="nav-text">神经网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">8.52.</span> <span class="nav-text">图神经网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="nav-number">8.53.</span> <span class="nav-text">大数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98"><span class="nav-number">8.54.</span> <span class="nav-text">数据挖掘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE"><span class="nav-number">8.55.</span> <span class="nav-text">区块链</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="水木君"
      src="https://bigshuimu.oss-cn-nanjing.aliyuncs.com/personal/cat.jpg">
  <p class="site-author-name" itemprop="name">水木君</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bigshuimu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bigshuimu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://armke.github.io/" title="https:&#x2F;&#x2F;armke.github.io&#x2F;" rel="noopener" target="_blank">armke</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">水木君</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
